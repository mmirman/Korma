of : tm -> tp -> type.
%name of Of of.

of/empty : of empty unit.
of/obj : of (obj L R) (prod Tl Tr)
       <- of R Tr 
       <- of L Tl
       <- tp-mode Tr M
       <- tp-mode Tl M.

of/getLeft : of (getLeft O) A
          <- of O (prod A B).
of/getRight : of (getRight O) B
	    <- of O (prod A B).
of/left : of (left L Rt) (sum Lt Rt M)
       <- of L Lt
       <- tp-mode-safe Rt Rm
       <- tp-mode-safe Lt Lm
       <- ub Lm Rm M.
of/right : of (right Lt R)  (sum Lt Rt M)
       <- of R Rt
       <- tp-mode-safe Rt Rm
       <- tp-mode-safe Lt Lm
       <- ub Lm Rm M.
% switch should be GLB not LUB, but right now just making them equal seems good enough.
of/switch : of (switch L R O) C
	      <- of O (sum A B M)
	      <- of R (B ~> C) 
	      <- of L (A ~> C)
	      <- tp-mode B M
	      <- tp-mode A M.

of/logic-var : tp-mode-safe B neg -> of logic-var B.

of/unsafe : tp-mode-safe B M -> of unsafe B.

of/subsump : of (sub E) T'
          <- of E T
          <- T =< T'
          <- tp-mode-safe T' M. % derivations can be specialized.

of/@s : of Ef (A ~> C) -> of Ev A -> of (@s Ef Ev) C.

of/lam : of (lam F A) (A ~> B)
      <- tp-mode-safe B OutMode
      <- tp-mode-safe A InMode
      <- ({x} of x A -> of (F x) B).



%block of-b : some {t}{x : tm} block {_:of x t}.
%worlds (of-b | tm-b) (of _ _).



used-as-neg : {Result : mode } tm -> tp -> tm -> tp -> type.

used-as-neg/e : used-as-neg neg A T A T.

used-as-neg/sX : used-as-neg M (sub X) _ A T'
	      <- of X T
              <- used-as-neg M X T A T'.

used-as-neg/sV : used-as-neg M X T (sub A) _
	      <- of A T'
              <- used-as-neg M X T A T'.

used-as-neg/getLeft : used-as-neg ResM A T (getLeft E) L
		   <- of E (prod L R)
                   <- used-as-neg ResM A T E (prod L R).

used-as-neg/getRight : used-as-neg ResM A T (getRight E) R
                    <- of E (prod L R)
                    <- used-as-neg ResM A T E (prod L R).

used-as-neg/lam-inner : used-as-neg ResM A T (lam F I) (I ~> O)
                     <- tp-mode-safe I _
                     <- ({x} of x I -> used-as-neg ResM A T (F x) O).

used-as-neg/app-l : used-as-neg ResM X T (@s E1 E2) O
                 <- of E1 (I ~> O)
                 <- used-as-neg ResM X T E1 (I ~> O).

used-as-neg/app-r 
   : used-as-neg ResM X T (@s F V) O
  <- of F (Vt ~> O)
  <- of V Vt
  <- tp-mode Vt neg
  <- used-as-neg neg X T V Vt.

used-as-neg/objL : used-as-neg ResM X T (obj L R) (prod Lt Rt)
		<- tp-mode Rt neg
		<- tp-mode Lt neg
                <- used-as-neg ResM X T L Lt.

used-as-neg/objR : used-as-neg ResM X T (obj L R) (prod Lt Rt)
		<- tp-mode Rt neg
		<- tp-mode Lt neg
                <- used-as-neg ResM X T R Rt.

used-as-neg/obj : used-as-neg ResM X T (obj L R) (prod Lt Rt)
                <- used-as-neg ResM X T R Rt
                <- used-as-neg ResM X T L Lt.

used-as-neg/product : used-as-neg ResM A (prod Tl Tr) E T'
                   <- used-as-neg ResM (getRight A) Tr E T'
                   <- used-as-neg ResM (getLeft A) Tl E T'.

used-as-neg/sum-unused : used-as-neg ResM A T (switch L R I) O
		      <- of R (Rt ~> O)
		      <- of L (Lt ~> O)
		      <- of I (sum Lt Rt _)
                      <- used-as-neg ResM A T R (Rt ~> O)
                      <- used-as-neg ResM A T L (Lt ~> O).

used-as-neg/sum-used : used-as-neg ResM A T (switch L R I) O
		    <- of R (Rt ~> O)
		    <- of L (Lt ~> O)
		    <- of I (sum Lt Rt M )
                    <- used-as-neg ResM A T I (sum Lt Rt M).

used-as-neg/left : used-as-neg ResM A T (left L Rt) (sum Lt Rt _)
                <- used-as-neg ResM A T L Lt.

used-as-neg/right : used-as-neg ResM A T (right Lt R) (sum Lt Rt _)
      	         <- used-as-neg ResM A T R Rt.


used-neg : mode -> of E T -> of E' T' -> type.
used-neg/uneg : used-neg M (_ : of E T) (_ : of E' T') 
	     <- used-as-neg M E T E' T'. 
%freeze used-neg.

get-used-as-neg : used-neg M (_ : of E T) (_ : of E' T') -> used-as-neg M E T E' T' -> type.
%mode get-used-as-neg +A -B.
- : get-used-as-neg (used-neg/uneg A) A.
%worlds () (get-used-as-neg _ _).
%total {A} (get-used-as-neg A _).

well-moded : of E T -> type.

wm/empty : well-moded of/empty.
wm/obj : well-moded (of/obj _ _ OfL OfR) <- well-moded OfR <- well-moded OfL.
wm/getLeft : well-moded (of/getLeft Of) <- well-moded Of.
wm/getRight : well-moded (of/getRight Of) <- well-moded Of.
wm/left : well-moded (of/left _ _ _ Of) <- well-moded Of.
wm/right : well-moded (of/right _ _ _ Of) <- well-moded Of.
wm/switch : well-moded (of/switch _ _ OfL OfR OfI) <- well-moded OfI <- well-moded OfR <- well-moded OfL.
wm/logic-var : well-moded (of/logic-var _).
wm/subsump : well-moded (of/subsump _ _ Of) <- well-moded Of.
wm/@s : well-moded (of/@s OfF OFV) <- well-moded OfV <- well-moded OfF.
wm/lam/+* : well-moded (of/lam F_Of (TmsA : tp-mode-safe A pos) TmsB)
         <- ({x}{of_x} well-moded of_x -> well-moded (F_Of x of_x)).

wm/lam/- : well-moded (of/lam F_Of (TmsA : tp-mode-safe A neg) (TmsB : tp-mode-safe _ M) )
      <- ({x}{of_x : of x A} used-neg M of_x (F_Of x of_x))
      <- ({x}{of_x : of x A} well-moded of_x -> well-moded (F_Of x of_x)).

%block wm-assm-b : some {t} block {x}{of_x:of x t}{_:well-moded of_x}.

