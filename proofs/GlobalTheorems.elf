% Fun fact: percent dot ends the file

pres : step E E' -> of E T -> of E' T' -> T' =< T -> type.
%mode pres +Step +T -T' -Sub.

pres/compose : pres (step/compose StepBC StepAB) OfA OfC SubCA
            <- pres StepAB OfA OfB SubBA
            <- pres StepBC OfB OfC SubCB
            <- =<-trans SubCB SubBA SubCA.

pres/sub : pres Step (of/subsump TmsT SubT*T OfET*) OfE'T' SubT'T
        <- pres Step OfET* OfE'T' SubT'T*
        <- =<-trans SubT'T* SubT*T SubT'T.

pres/@s : pres (step/@s Step) (of/@s OfEf OfEv) (of/@s OfEf' OfEv) Subb'b
       <- pres Step OfEf OfEf' (=</~> Subaa' Subb'b).

pres/lam-subsump 
   : pres step/lam (of/@s (of/subsump _ (=</~> SubAA' SubB'B) OfFA'B') OfA) OfB* SubB*B
  <- of-safe OfFA'B' (tp-mode-safe/~> TmsA' TmsB')
  <- pres step/lam (of/@s OfFA'B' (of/subsump TmsA' SubAA' OfA)) OfB* SubB*B'
  <- =<-trans SubB*B' SubB'B SubB*B.

pres/lam : pres 
            step/lam
	    (of/@s (of/lam OfF InMode OutMode) (OfVVt))
	    (OfF V Vt (sm InMode) Eq' OfVVt)
	    Eq
         <- =<-eq Vt Eq'
         <- =<-eq Ot Eq.

pres/getLeft-subsump 
  : pres Step (of/getLeft (of/subsump (tp-mode-safe/prod _ TmsL TmsR) (=</prod SubL'L SubR'R) OfO')) Of Sub
 <- of-safe OfO' (tp-mode-safe/prod _ TmsL' TmsR')
 <- pres Step (of/subsump TmsL SubL'L (of/getLeft OfO')) Of Sub.

pres/getLeft : pres step/getLeft (of/getLeft (of/obj OfL OfR)) OfL Eq <- =<-eq _ Eq. 

pres/getRight-subsump
  : pres Step (of/getRight (of/subsump (tp-mode-safe/prod _ TmsL TmsR) (=</prod SubL'L SubR'R) OfO')) Of Sub
 <- of-safe OfO' (tp-mode-safe/prod _ TmsL' TmsR')
 <- tms-2-tm TmsR' TmR'
 <- tms-2-tm TmsL' TmL'
 <- pres Step (of/subsump TmsR SubR'R (of/getRight OfO')) Of Sub.

pres/getRight : pres step/getRight (of/getRight (of/obj OfL OfR)) OfR Eq <- =<-eq _ Eq. 

pres/getLeft-simp : pres (step/getLeft-simp Step _) (of/getLeft OfObj) (of/getLeft OfObj') SubL
                 <- pres Step OfObj OfObj' (=</prod SubL SubR)
                 <- of-safe OfObj' (tp-mode-safe/prod _ TmsL' TmsR')
                 <- tms-2-tm TmsR' TmR'
                 <- tms-2-tm TmsL' TmL'. 

pres/getRight-simp : pres (step/getRight-simp Step _) (of/getRight OfObj) (of/getRight OfObj') SubR
                 <- pres Step OfObj OfObj' (=</prod SubL SubR)
                 <- of-safe OfObj' (tp-mode-safe/prod _ TmsL' TmsR')
                 <- tms-2-tm TmsR' TmR'
                 <- tms-2-tm TmsL' TmL'. 

pres/switch-simp : 
     pres (step/switch-simp Step _) 
          (of/switch TmsL TmsR OfFl OfFr OfO) 
	  (of/switch TmsL TmsR OfFl OfFr (of/subsump TmsOt SubO'O OfO'))
          Eq
  <- pres Step OfO OfO' SubO'O
  <- of-safe OfO TmsOt
  <- =<-eq _ Eq.

pres/switch-subsump 
   : pres 
      Step
      (of/switch TmL TmR OfFl OfFr
	 (of/subsump (tp-mode-safe/sum UbM Tms'L Tms'R) (=</sum SubM'M SubL'L SubR'R) OfO'))
      Of'
      Sub 
  <- =<-eq _ Eq
  <- of-safe OfO' (tp-mode-safe/sum _ TmsL' TmsR')
  <- of-safe (of/switch TmL TmR OfFl OfFr
	        (of/subsump (tp-mode-safe/sum UbM Tms'L Tms'R) (=</sum SubM'M SubL'L SubR'R) OfO'))
     TmsC
  <- tms-2-tm TmsR' TmR'
  <- tms-2-tm TmsL' TmL'
  <- pres
     Step
     (of/switch TmL' TmR'
	(of/subsump (tp-mode-safe/~> TmsL' TmsC) (=</~> SubL'L Eq) OfFl)
	(of/subsump (tp-mode-safe/~> TmsR' TmsC) (=</~> SubR'R Eq) OfFr)
	OfO' 
     ) 
     Of' 
     Sub.

pres/switch-left : pres 
    step/switch-left 
    (of/switch TmsL TmsR OfFl OfFr (of/left _ _ _ OfL))
    (of/@s OfFl OfL)
    Eq
 <- =<-eq _ Eq.

pres/switch-right : pres 
    step/switch-right
    (of/switch TmsL TmsR OfFl OfFr (of/right _ _ _ OfR))
    (of/@s OfFr OfR)
    Eq
 <- =<-eq _ Eq.

%worlds () (pres _ _ _ _).

%{ 
we will need a lemma to get terminates working, 
but for now, we know it works 
for the pres/switch-subsump cases because 
we always move the of/subsump to the OfFl and OfFr from the OfO'
so eventually we will match again'st something with of/left or of/right instead of of/subsump for OfO'
and in those two cases, we don't match against OfFl or OfFr.

The same goes for lam, getLeft and getRight.

We also never match on the outputs except where it obviously works, so output coverage should succeed.
}%
%covers pres +A +B -C -D.
%trustme %total {A B} (pres A B _ _).
%freeze pres.

pres-wm : pres _ OfA OfB _ -> well-moded OfA -> well-moded OfB -> type.
%mode pres-wm +A +B -C.
%worlds () (pres-wm _ _ _).
%trustme %total {A B} (pres-wm A B _).


get-pres : {Step: step E E' } {Of : of E T} pres Step Of Of' Sub -> type.
%mode get-pres +A +B -C.
%worlds (all-b') (get-pres _ _ _).
%trustme %total {A B} (get-pres A B _).


%{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Some lemmas for unpacking and effectiveness
}%
not-stuck : tm -> type.
not-stuck/value : value A -> not-stuck A.
not-stuck/step : step E E' -> not-stuck E.

progress : of E Xt -> not-stuck E -> type.
%mode progress +A -B.
%worlds () (progress _ _).
%trustme %total {A} (progress A _).



tms-unique : tp-mode-safe A pos -> tp-mode-safe A neg -> absurd -> type.
%mode tms-unique +A +B -C.
%worlds (all-b'') (tms-unique _ _ _).
%total {A B} (tms-unique A B _).

tm-unique : tp-mode A pos -> tp-mode A neg -> absurd -> type.
%mode tm-unique +A +B -C.
%worlds (all-b'') (tm-unique _ _ _).
%total {A B} (tm-unique A B _).

from-absurd-ll : {OfX} absurd -> logic-less OfX -> type.
%mode from-absurd-ll +Of +A -L.
%worlds (all-b'') (from-absurd-ll _ _ _).
%total {O A} (from-absurd-ll O A _).





%{
This theorem essentially ensures used-as-neg and logic-less have corrosponding interests in 
logicless and used as negative terms.
}%
uan-2-ll : used-as-neg R OfX OfV 
        -> logic-less OfV
        -> logic-less OfX
        -> type.


%block uan-2-ll-b : some {t} block {x}{t'}{_: safe-moded t'}{_:t' =< t}{of: of x t'}{_ : logic-less of}.

- : {x}{t'}{sm_t'}{s}{ofx}{ll_x} 
    uan-2-ll (F_UAN x t' sm_t' s ofx) (F_LL_I x t' sm_t' s ofx ll_x) (LL_X x t' sm_t' s ofx ll_x)
 -> uan-2-ll (used-as-neg/lam-inner F_UAN) (logic-less/lam F_LL_I) (LL_X x t' sm_t' s ofx ll_x) .

- : uan-2-ll (used-as-neg/product UAN_XL UAN_XR) LL_E LL_X
 <- uan-2-ll UAN_XR LL_E (logic-less/getRight LL_X).


- : uan-2-ll used-as-neg/e LLV LLV.

- : uan-2-ll (used-as-neg/app-l UAN_F) (logic-less/app LL_F LL_V) LL_X
 <- uan-2-ll UAN_F LL_F LL_X.
- : uan-2-ll (used-as-neg/app-r UAN_V TmsV-) (logic-less/app LL_F LL_V) LL_X
 <- uan-2-ll UAN_V LL_V LL_X.
- : uan-2-ll (used-as-neg/objL UAN_L TmL-) (logic-less/obj LL_L LL_R) LL_X
 <- uan-2-ll UAN_L LL_L LL_X.
- : uan-2-ll (used-as-neg/objL UAN_L TmL-) (logic-less/obj-l LL_L _) LL_X
 <- uan-2-ll UAN_L LL_L LL_X.
- : uan-2-ll (used-as-neg/objL UAN_L TmL-) (logic-less/obj-r LL_R TmsL+) LL_X
 <- tms-2-tm TmsL+ TmL+
 <- tm-unique TmL+ TmL- Absurd
 <- from-absurd-ll _ Absurd LL_X.

- : uan-2-ll (used-as-neg/objR UAN_R TmR-) (logic-less/obj LL_L LL_R) LL_X
 <- uan-2-ll UAN_R LL_R LL_X.
- : uan-2-ll (used-as-neg/objR UAN_R TmR-) (logic-less/obj-r LL_R _) LL_X
 <- uan-2-ll UAN_R LL_R LL_X.
- : uan-2-ll (used-as-neg/objR UAN_R TmR-) (logic-less/obj-l LL_L TmsR+) LL_X
 <- tms-2-tm TmsR+ TmR+
 <- tm-unique TmR+ TmR- Absurd
 <- from-absurd-ll _ Absurd LL_X.

- : uan-2-ll (used-as-neg/sum-unused UAN_XL UAN_XR) (logic-less/switch LL_L LL_R LL_I) LL_X
 <- uan-2-ll UAN_XL LL_L LL_X.

- : uan-2-ll (used-as-neg/sum-used UAN_XI) (logic-less/switch LL_L LL_R LL_I) LL_X
 <- uan-2-ll UAN_XI LL_I LL_X.

- : uan-2-ll (used-as-neg/left UAN_XI) (logic-less/left LL_I) LL_X
 <- uan-2-ll UAN_XI LL_I LL_X.

- : uan-2-ll (used-as-neg/right UAN_XI) (logic-less/right LL_I) LL_X
 <- uan-2-ll UAN_XI LL_I LL_X.


%mode (uan-2-ll +UanXV +LLV -LLX).
%worlds (uan-2-ll-b) (uan-2-ll _ _ _).
%total {A B} (uan-2-ll A B _).


%.


resolving : used-as-neg Result OfX OfE 
	 -> pres (Step : step E V) (OfE : of E Et) OfV SubVE
	 -> tp-mode-safe Et pos

         -> well-moded OfX
         -> well-moded OfE

	 -> logic-less OfV
	 -> logic-less OfX 
	 -> type.
%mode resolving +UanXE +Pres +TmsEp +WM_X +WM_E +LLV -LLX.


res/comp : resolving OfX UanXE (pres/compose (_ : =<-trans SubCB SubBA SubCA) (PresBC: pres _ OfB _ _) PresAB) TmsA_pos LLC LLA
        <- pos-is-bot SubBA TmsA_pos TmsB_pos
        <- resolving OfB used-as-neg/e PresBC TmsB_pos LLC LLB
        <- resolving OfX UanXE PresAB TmsA_pos LLB LLA.

res/@s/app-l
  : resolving OfX (used-as-neg/app-l UanXE1) (pres/@s (Pres : pres _ OfEf _ _)) TmsA_pos (logic-less/app LLFe LLIe) LLX
 <- of-safe OfEf (tp-mode-safe/~> TmsA TmsB)
 <- resolving OfX UanXE1 Pres (tp-mode-safe/~> TmsA TmsB) LLFe LLX.

res/@s/app-r
  : resolving 
     (OfX : of X Xt)
     (used-as-neg/app-r UanXEv TmA- OfEf_A~>B  : used-as-neg _ Xt X (@s Ef Ev))
     (pres/@s Pres : pres _ (of/@s _ OfEv) _ _)
     TmsB+
     (logic-less/app LLEf' LLEv : logic-less (_: of (@s Ef' Ev) _)) 
     LLX
 <- uan-2-ll UanXEv LLEv LLX.

res/switch-left
 : resolving 
    OfX
    (used-as-neg/sum-unused UAN-L UAN-R)
    (_ : pres step/switch-left _ _ _)
    TmsB+
    (logic-less/app LL-Fe LL-Ie)
    LL-X
 <- uan-2-ll OfX UAN-L LL-Fe LL-X.

res/switch-right
 : resolving 
    OfX
    (used-as-neg/sum-unused UAN-L UAN-R)
    (_ : pres step/switch-right _ _ _)
    TmsB+
    _
    _
    (logic-less/app LL-Fe LL-Ie)
    LL-X
 <- uan-2-ll OfX UAN-R LL-Fe LL-X.

res/@s/app-r/lam
 : resolving 
    (used-as-neg/app-r UanXEv _ (of/lam _ _ _ (used-neg/- UanF _ _)))
    (_ : pres _ (of/@s _ (OfEv : of Ev Vt)) _ Eq)
    TmsB+
    _ _
    LLr
    LLX
 <- uan-2-ll (UanF Ev Vt Eq OfEv) LLr LLV
 <- uan-2-ll UanXEv LLV LLX.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%worlds () (resolving _ _ _ _ _ _) (resolving-value _ _ _ _ _).
%trustme %total {O A B C} (resolving-value O A B C _).

% %total {O A B C} (resolving O A B C _).











%{








used-as-neg-context : type.
uan-context/d : used-as-neg-context
	     <- step E V
	     <- logic-less (OfV : of V Vt)
             <- of E Et
             <- tp-mode-safe Et pos
             <- ({A}{At} of A At -> tp-mode-safe At neg -> used-as-neg pos At A E).


resolving : used-as-neg-context
         -> pres Step (OfAeAt : of _ At) OfBeBt SubBtAt
         -> tp-mode-safe At pos
         -> logic-less OfBeBt
         -> logic-less OfAeAt
         -> type.

%mode resolving +C +Pres +TmsP +LL -LL'.


res/getLeft/r-pos
  : resolving Context
              (pres/getLeft _ : pres step/getLeft (of/getLeft (of/obj OfL (OfR : of R Rt))) OfL Eq) 
              TmsL_pos 
              LL_L 
              (logic-less/getLeft (logic-less/obj-l LL_L TmsR_pos))
 <- of-safe OfR TmsR_pos.

res/getLeft/r-neg
  : resolving (uan-context/d Foo TmsE+ OfE LLV StepEV) 
              (pres/getLeft _ : pres step/getLeft (of/getLeft (of/obj OfL (OfR : of R Rt))) OfL Eq) 
              TmsL_pos 
              LL_L
              (logic-less/getLeft (logic-less/obj LL_L LL_R))
 <- of-safe OfR TmsR_neg
 <- {E}{V}{Step : step E V}{Vt}{OfV : of V Vt}{LLV : logic-less OfV} (Context R Rt OfR TmsR_neg) .

%{ <- get-pres StepEV OfE PresEV
 <- resolving (uan-context/d LLV Foo TmsE+ OfE ValV StepEV) PresEV TmsE+ LLV LLE
 <- used-as-neg.
 <- used-as-neg-2-logic-less OfR (Foo R Rt OfR TmsR_neg) OfE TmsE+ LL_R. }%

res/subsump : resolving Context Pres TmsA_pos (logic-less/sub Of) Of.

res/pres : resolving Context (pres/compose (_ : =<-trans SubCB SubBA SubCA) PresBC PresAB) TmsA_pos LLC LLA
        <- pos-is-bot SubBA TmsA_pos TmsB_pos
        <- resolving Context PresBC TmsB_pos LLC LLB
        <- resolving Context PresAB TmsA_pos LLB LLA.

res/sub
  : resolving Context (pres/sub _ Pres) TmsA_pos LL (logic-less/sub LL')
 <- resolving Context Pres TmsA_pos LL LL'.

res/@s/app 
  : resolving Context (pres/@s Trans (Pres : pres _ OfEf _ _)) TmsA_pos (logic-less/app LLFe LLIe) (logic-less/app LLFe' LLIe)
 <- of-safe OfEf (tp-mode-safe/~> TmsA TmsB)
 <- resolving Context Pres (tp-mode-safe/~> TmsA TmsB) LLFe LLFe'.

res/@s/-+ 
 : resolving Context (pres/@s Trans Pres) TmsA_pos 
    (logic-less/app-+ TmsA_pos' LLIe)
    (logic-less/app-+ TmsA_pos LLIe).

res/@s/++ 
 : resolving Context (pres/@s (Trans : =<-trans Subva Subaa' Subva') Pres ) TmsB+
    (logic-less/app++ TmsA'+ TmsB'+)
    (logic-less/app++ TmsA+ TmsB+)
 <- pos-is-bot Subaa' TmsA'+ TmsA+.

     


%worlds () (resolving _ _ _ _ _).
% %total {A B C D} (resolving A B C D _).



2p0 : resolving UAN 
                (step/getLeft-simp Step NotValE1) 
                (of/getLeft TmL TmR OfO)
                Lpos 
                (logic-less/getLeft LogicLessObj) 
                (logic-less/getLeft LogicLessObj')
   <- of-safe OfO TmsO
   <- resolving UAN Step OfO TmsO LogicLessObj LogicLessObj'.

4 : resolving _ (step/switch-left _ _ )
                : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).

5 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).
6 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).

7 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
8 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).
9 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).

%% somehow the positivity of the result, 
%% and the positivity of the first argument imply the non check of the logic-less


12 : resolving 
     (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) _ TmB B'eB) : step (@s (lam V (used-neg/+* Arg_Is_Pos)) E S) TmB B'eB)
     Init_Result_Pos
     LogicLessTmB
     (logic-less/app++ Arg_Is_Pos Init_Result_Pos).

% might need to prove an equality lemma for GetSubRes.
13 : resolving
      (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) B' TmB B'eB) 
        : step (@s (lam V (used-neg/-+ ProveUsedAsNeg Arg_Is_Neg _)) _ _) _ _)
      Init_Result_Pos
      LogicLessTmB
      (logic-less/app-+ Init_Result_Pos LogicLessE)
  <- unpack-used-as-neg' (ProveUsedAsNeg (subRes/dual T E S) T E S getSubRes/get) UsedAsNeg
  <- used-as-neg-2-logic-less UsedAsNeg Init_Result_Pos LogicLessE.



% "ProveUsedAsNeg T S E E_Is_Neg" should show that "logic-less E"
% somehow we also would need E_Is_Neg or at least, E could be Neg.
% to get E_Is_Neg, we need to know that the input is Neg for logic-less.
% perhaps LogicLessTmB should be entered?  (or not, it feels a bit weird doing that).


%worlds () (resolving _ _ _ _).
%total {A B} (resolving A _ B _).
}%