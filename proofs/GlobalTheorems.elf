%{ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

we need step and  "logic-less Be"
so that we know that Ae, despite being positively moded is actually 
free of logic variables by having progress.  
The existence of logic variables should hinder progress in a positively moded "thing"
so the existence of progress should imply no logic variables.

Since the existence of progress implies no logic variables, 
then the A that "findAll F" returns 
(where A is such that "step (F A) Success" and F returns positive and success contains no logic variables) 
must also contain no logic variables.

i think (@s (A: _/+ ~> _/+) (B : _/-) _) : _/- for this all to work.  which is an odd exception case, 
more accurately, "+ ~> +" is actually "- ~> -"
but corresponds to not actually being negative. that, or no right hand side steps. 
that InputIsPos is an argument to resolving why we need this stuff.
so we need a lemma that says (F I: A/+) => F:R/+ ~> O/+ => I:R/+.

}%

pres : step E E' -> of E T -> of E' T' -> T' =< T -> type.
%mode pres +Step +T -T' -Sub.


pres/sub : pres Step (of/subsump  TmsT SubT*T OfET* : of E T) 
                     OfE'T' SubT'T
        <- pres Step OfET* OfE'T' SubT'T*
        <- =<-trans SubT'T* SubT*T SubT'T.

pres/e : pres step/e Of Of Eq <- =<-eq _ Eq.

pres/@s : pres (step/@s Step) (of/@s OfEf OfEv Subva) (of/@s OfEf' OfEv Subva') Subb'b
       <- pres Step OfEf OfEf' (=</~> Subaa' Subb'b)
       <- =<-trans Subva Subaa' Subva'.

pres/lam : pres 
            step/lam
	    (of/@s (of/lam OfF _ _ _) OfVVt SubVtAt)
	    (OfF E Vt SubVtAt OfVVt)
	    Eq <- =<-eq _ Eq.

pres/getLeft : pres step/getLeft (of/getLeft _ _ (of/obj OfL OfR)) OfL Eq <- =<-eq _ Eq. 
pres/getRight : pres step/getRight (of/getRight _ _ (of/obj OfL OfR)) OfR Eq <- =<-eq _ Eq. 

pres/getLeft-simp : pres (step/getLeft-simp Step _) (of/getLeft TmL TmR OfObj) (of/getLeft TmL' TmR' OfObj') SubL
                 <- pres Step OfObj OfObj' (=</prod SubL SubR)
                 <- of-safe OfObj' (tp-mode-safe/prod _ TmsL' TmsR')
                 <- tms-2-tm TmsR' TmR'
                 <- tms-2-tm TmsL' TmL'. 

pres/getRight-simp : pres (step/getRight-simp Step _) (of/getRight TmL TmR OfObj) (of/getRight TmL' TmR' OfObj') SubR
                 <- pres Step OfObj OfObj' (=</prod SubL SubR)
                 <- of-safe OfObj' (tp-mode-safe/prod _ TmsL' TmsR')
                 <- tms-2-tm TmsR' TmR'
                 <- tms-2-tm TmsL' TmL'. 

pres/switch-simp : 
     pres (step/switch-simp Step _) 
          (of/switch TmsC TmsL TmsR OfFl OfFr OfO) 
	  (of/switch TmsC TmsL TmsR OfFl OfFr (of/subsump TmsOt SubO'O OfO'))
          Eq
  <- pres Step OfO OfO' SubO'O
  <- of-safe OfO TmsOt
  <- =<-eq _ Eq.

pres/switch-subsump : pres 
    Step
    (of/switch TmsC TmsL TmsR OfFl OfFr (of/subsump (tp-mode-safe/sum UbM Tms'L Tms'R) (=</sum SubM'M SubL'L SubR'R) OfO'))
    Of'
    Sub
 <- =<-eq _ Eq
 <- pres Step (of/switch TmsC TmsL TmsR 
          (of/subsump (tp-mode-safe/~> TmsL TmsC) (=</~> SubL'L Eq) OfFl) 
          (of/subsump (tp-mode-safe/~> TmsR TmsC) (=</~> SubR'R Eq) OfFr) 
          OfO') Of' Sub.

pres/switch-left : pres 
    step/switch-left 
    (of/switch _ TmsL TmsR OfFl OfFr (of/left _ _ _ OfL))
    (of/@s OfFl OfL Eq')
    Eq
 <- =<-eq _ Eq'
 <- =<-eq _ Eq.

pres/switch-right : pres 
    step/switch-right
    (of/switch _ TmsL TmsR OfFl OfFr (of/right _ _ _ OfR))
    (of/@s OfFr OfR Eq')
    Eq
 <- =<-eq _ Eq'
 <- =<-eq _ Eq.

%worlds () (pres _ _ _ _).
%trustme %terminates {A B} (pres A B _ _).
%covers pres +A +B -C -D.
%freeze pres.

%{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Some lemmas for unpacking and effectiveness
}%

used-as-neg-2-logic-less : {OfET : of E T} used-as-neg Result T E E' 
                        -> of E' T' 
                        -> tp-mode-safe T' pos 
                        -> logic-less OfET -> type.
%mode used-as-neg-2-logic-less +OfET +UsedAsNeg +Of +Pos -LogicLess.

%worlds () (used-as-neg-2-logic-less _ _ _ _ _).
%trustme %total {O A B C} (used-as-neg-2-logic-less O A B C _).

used-as-neg-somewhere : type.
used-as-neg-somewhere/d : used-as-neg-somewhere
                       <- step E V
                       <- value V
                       <- of E Et
                       <- tp-mode-safe Et pos
                       <- ({A}{At} of A At -> tp-mode-safe At neg -> used-as-neg pos At A E).

resolving : used-as-neg-somewhere
         -> {OfAeAt : of Ae At}
	    step Ae Be
         -> {OfBeBt : of Be Bt}
	    Bt =< At
         -> tp-mode-safe At pos
         -> logic-less OfBeBt
         -> logic-less OfAeAt
         -> type.

- : resolving _ _ step/e _ _ _ A A. 

0 : resolving _ _ (_ : step (@s E1 _) (@s E1 _)) _ _ _ (logic-less/app++ Arg_Pos Arg_Neg) (logic-less/app++ Arg_Pos Arg_Neg).

2p0 : resolving UAN 
                (of/getLeft TpmL TpmR OfProd)
                (step/getLeft-simp Step NotValE1) 
                (of/getLeft TpmL' TpmR' OfProd')
                _
                Lpos 
                (logic-less/getLeft LogicLessObj) 
                (logic-less/getLeft LogicLessObj')
   <- resolving UAN _ Step _ _ (tp-mode/prod lub/e) LogicLessObj (LogicLessObj' : logic-less L).

4 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
5 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).
6 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).

7 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
8 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).
9 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).

10 : resolving (step/@s _ StepE1tE1') Init_Result_Pos (logic-less/app LLFe LLIe) (logic-less/app LLFe' LLIe) 
  <- resolving StepE1tE1' tp-mode/~> LLFe LLFe'.

11 : resolving
      (step/@s Trans Step)
      Init_Result_Pos
      (logic-less/app-+ Init_Result_Pos' LLIe)
      (logic-less/app-+ Init_Result_Pos LLIe).

%% somehow the positivity of the result, 
%% and the positivity of the first argument imply the non check of the logic-less

12 : resolving 
     (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) _ TmB B'eB) : step (@s (lam V (used-neg/+* Arg_Is_Pos)) E S) TmB B'eB)
     Init_Result_Pos
     LogicLessTmB
     (logic-less/app++ Arg_Is_Pos Init_Result_Pos).

% might need to prove an equality lemma for GetSubRes.
13 : resolving
      (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) B' TmB B'eB) 
        : step (@s (lam V (used-neg/-+ ProveUsedAsNeg Arg_Is_Neg _)) _ _) _ _)
      Init_Result_Pos
      LogicLessTmB
      (logic-less/app-+ Init_Result_Pos LogicLessE)
  <- unpack-used-as-neg' (ProveUsedAsNeg (subRes/dual T E S) T E S getSubRes/get) UsedAsNeg
  <- used-as-neg-2-logic-less UsedAsNeg Init_Result_Pos LogicLessE.



% "ProveUsedAsNeg T S E E_Is_Neg" should show that "logic-less E"
% somehow we also would need E_Is_Neg or at least, E could be Neg.
% to get E_Is_Neg, we need to know that the input is Neg for logic-less.
% perhaps LogicLessTmB should be entered?  (or not, it feels a bit weird doing that).


%worlds () (resolving _ _ _ _).
%mode resolving +A +B +C -D.
%total {A B} (resolving A _ B _).
