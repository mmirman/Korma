% twelf-server-send-command "set unsafe true"
%%%%%%%%%%%%%%%%%%%%%%%%
% what resolvedness is %
%%%%%%%%%%%%%%%%%%%%%%%%

mode : type. %name mode Gs.
pos : mode.
neg : mode.
%block m-b : block {_ : mode}.
%worlds () (mode).
%freeze mode.

<m : mode -> mode -> type. %infix right 5 <m.  %name <m SubM.
%mode <m +A +B. 
<m/e : A <m A.
<m/pn : pos <m neg.
%worlds (m-b) (<m _ _).
%unique <m +A +B.
%freeze <m.


<m-trans : A <m B -> B <m C -> A <m C -> type.
%mode <m-trans +A +B -C.
- : <m-trans <m/e A A.
- : <m-trans <m/pn <m/e <m/pn.
%worlds () (<m-trans _ _ _).
%unique <m-trans +A +B -1C.
%total {A B} (<m-trans A B _).


ub : mode -> mode -> mode -> type.  %name ub UB.
%mode ub +A +B +C.
ub/p : A <m C -> B <m C -> ub A B C.
%worlds (m-b) (ub _ _ _).
%unique ub +A +B +C.

lub : mode -> mode -> mode -> type. %name lub LUB. 
%mode lub +A +B -C.  
lub/e :  lub A A A.
lub/pl : lub pos neg neg.
lub/pr : lub neg pos neg.
%worlds () (lub _ _ _).
%unique lub +A +B -1C.
%total {A B} (lub A B _).

lub-2-ub : lub A B C -> ub A B C -> type.
%mode lub-2-ub +A -B.
- : lub-2-ub lub/e (ub/p <m/e <m/e).
- : lub-2-ub lub/pl (ub/p <m/pn <m/e).
- : lub-2-ub lub/pr (ub/p <m/e <m/pn).
%worlds () (lub-2-ub _ _).
%unique lub-2-ub +A -1B.
%total {A} (lub-2-ub A _).

glb : mode -> mode -> mode -> type. %name glb GLB.
%mode glb +A +B -C. 
glb/e : glb A A A.
glb/pl : glb pos neg pos.
glb/pr : glb neg pos pos.
%worlds () (glb _ _ _).
%unique glb +A +B -1C.
%total {A B} (glb A B _).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the types in the language %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tp : type. %name tp T t.
~> : tp -> tp -> tp. %infix right 6 ~>.
unit : tp.
sum : tp -> tp -> mode -> tp.
prod : tp -> tp -> tp.
%block tp-b : block {T : tp}.
%worlds (tp-b) (tp).

tp-mode : tp -> mode -> type. %name tp-mode TpM tpM.
%mode tp-mode +A -B.
tp-mode/~> : tp-mode (B ~> A) pos.
tp-mode/unit : tp-mode unit pos.
tp-mode/sum : tp-mode (sum Lt Rt C) C.
tp-mode/prod : tp-mode (prod Lt Rt) C <- tp-mode Rt Rm <- tp-mode Lt Lm <- lub Lm Rm C.

%worlds (tp-b) (tp-mode _ _).
%unique tp-mode +A -1B.

tp-mode-safe : tp -> mode -> type. %name tp-mode-safe TpM tpM.
%mode tp-mode-safe +A -B.
tp-mode-safe/~> : tp-mode-safe (A ~> B) pos <- tp-mode-safe B _ <- tp-mode-safe A _.
tp-mode-safe/unit : tp-mode-safe unit pos.
tp-mode-safe/sum : tp-mode-safe (sum Lt Rt C) C <- tp-mode-safe Rt Rm <- tp-mode-safe Lt Lm <- ub Lm Rm C.
tp-mode-safe/prod : tp-mode-safe (prod Lt Rt) C <- tp-mode-safe Rt Rm <- tp-mode-safe Lt Lm <- lub Lm Rm C.

%block tp-mode-always-safe : some {M} block {T}{_:tp-mode-safe T M}.

%worlds (tp-b | tp-mode-always-safe) (tp-mode-safe _ _).
%unique tp-mode-safe +A -1B.

tms-2-tm : tp-mode-safe T M -> tp-mode T M -> type.
%mode tms-2-tm +A -B.
- : tms-2-tm (tp-mode-safe/~> _ _) tp-mode/~>.
- : tms-2-tm (tp-mode-safe/unit) tp-mode/unit.
- : tms-2-tm (tp-mode-safe/sum _ _ _) tp-mode/sum.
- : tms-2-tm (tp-mode-safe/prod L A B) (tp-mode/prod L A' B') 
 <- tms-2-tm B B'
 <- tms-2-tm A A'.
%worlds (tp-b) (tms-2-tm _ _).
%unique tms-2-tm +A -1B.
%total {A} (tms-2-tm A _).


=< : tp -> tp -> type. %infix right 5 =<.
%mode =< +A +B.
=</unit : unit =< unit.
=</~> : A' =< A -> B =< B' -> (A ~> B) =< (A' ~> B').
=</sum :  M <m M'
       -> A =< A'
       -> B =< B'
       -> (sum A B M) =< (sum A' B' M').
=</prod :  A =< A'
        -> B =< B'
        -> (prod A B) =< (prod A' B').
%block sub-b : some {T}{T'} block {_: T =< T'}.
%worlds (sub-b | tp-b) (=< _ _).

%%$%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Some effectiveness lemmas %%
%%%$%%%%%%%%%%%%%%%%%%%%%%%%%%%

has-lub : {A}{B}{C} lub A B C -> type.
%mode has-lub +A +B -C -L.
- : has-lub A A A lub/e.
- : has-lub pos neg neg lub/pl.
- : has-lub neg pos neg lub/pr.
%worlds () (has-lub _ _ _ _).
%unique has-lub +A +B -1C -1L.
%total {A B} (has-lub A B _ _).

has-tp-mode : {T}{M} tp-mode T M -> type.
%mode has-tp-mode +A -B -C.
- : has-tp-mode unit pos tp-mode/unit.
- : has-tp-mode (_ ~> _) pos tp-mode/~>.
- : has-tp-mode (sum _ _ C) C tp-mode/sum.
- : has-tp-mode (prod A B) Cm (tp-mode/prod L A' B') 
 <- has-tp-mode B Bm B'
 <- has-tp-mode A Am A'
 <- has-lub Am Bm Cm L.

%worlds () (has-tp-mode _ _ _).
%unique has-tp-mode +A -1M -1TpM.
%total {A} (has-tp-mode A _ _).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the definition of a tm (again)        %%
%% and other stuff with progress theorem %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tm : type. %name tm E.

lam : (tm -> tm) -> tp -> tm.

empty : tm.
obj : tm -> tm -> tm.
getLeft : tm -> tm.
getRight : tm -> tm.
left : tm.
right : tm.
% switch should be GLB not LUB, but right now just making them equal seems good enough.
switch : tm
      -> tm
      -> tm.
logic-var : tm.
@s : tm -> tm -> tm.

%block tm-b : block {x : tm}.
%worlds (tm-b | tp-mode-always-safe) (tm).

used-neg : (tm -> tm) -> tp -> tp -> type.

of : tm -> tp -> type.

of/empty : of empty unit.
of/obj : of L Tl -> of R Tr -> of (obj L R) (prod Tl Tr).
of/getLeft : of (getLeft O) A
          <- of O (prod A B)
          <- tp-mode B M
          <- tp-mode A M.
of/getRight : of (getRight O) B
	    <- of O (prod A B)
	    <- tp-mode B M
	    <- tp-mode A M.
of/left : of left (Ta ~> sum Ta Tb Mc)
       <- tp-mode-safe Tb Mb
       <- tp-mode-safe Ta Ma
       <- ub Ma Mb Mc.
of/right : of right (Tb ~> sum Ta Tb Mc)
       <- tp-mode-safe Tb Mb
       <- tp-mode-safe Ta Ma
       <- ub Ma Mb Mc.
% switch should be GLB not LUB, but right now just making them equal seems good enough.
of/switch : of (switch L R) (sum A B MC ~> C)
	 <- of R (B ~> C) 
	 <- of L (A ~> C)
	 <- tp-mode-safe B MC
	 <- tp-mode-safe A MC
	 <- tp-mode-safe C MD.

of/logic-var : tp-mode-safe B neg -> of logic-var B.

of/subsump : tp-mode-safe T' M -> T =< T' -> of E T -> of E T'. % derivations can be specialized.

of/@s : of Ef (A ~> C) -> of Ev A' -> A' =< A -> of (@s Ef Ev) C.
of/lam : of (lam F A) (A ~> B)
      <- used-neg F A B
      <- tp-mode-safe B _
      <- tp-mode-safe A _
      <- ({x}{A'} A' =< A -> of x A' -> of (F x) B).


used-as-neg : {Result : mode } tp -> tm  -> tm -> type.


used-neg/+* : used-neg L T R
            <- tp-mode T pos.
used-neg/-- : used-neg L T R
	    <- tp-mode R neg
	    <- tp-mode T neg
	    <- ({x}{T'} T' =< T -> of x T' -> used-as-neg neg T' x (L x)).
used-neg/-+ : used-neg L T R
	    <- tp-mode R pos
	    <- tp-mode T neg
	    <- ({x}{T'} T' =< T -> of x T' -> used-as-neg pos T' x (L x)).

used-as-neg/e : used-as-neg neg _ A A.
used-as-neg/lam-inner : ({x}{T'} T' =< T -> of x T' -> used-as-neg ResM At A (F S)) 
		      -> used-as-neg ResM At A (lam F T).

used-as-neg/app-l : used-as-neg ResM At A E1 
                 -> used-as-neg ResM At A (@s E1 E2).

used-as-neg/app-r : used-as-neg ResM At A (@s E1 E2)
                 <- of E1 (T1 ~> T2)
                 <- used-as-neg neg At A E2
                 <- tp-mode T1 neg.

used-as-neg/objL : used-as-neg ResM At A (obj L R)
                <- of L To
		<- tp-mode To neg
                <- used-as-neg ResM At A L.

used-as-neg/objR : used-as-neg ResM At A (obj L R)
                <- of R To
		<- tp-mode To neg
                <- used-as-neg ResM At A R.

used-as-neg/product : used-as-neg ResM Lt (getLeft A) E 
                   -> used-as-neg ResM Rt (getRight A) E 
                   -> used-as-neg ResM (prod Lt Rt) A E.

used-as-neg/sum-unused : used-as-neg ResM At A L1 
                       -> used-as-neg ResM At A L2 
                       -> used-as-neg ResM At A (switch L1 L2).

%block assm-b : some {T} block {x : tm}{T' : tp}{_:T' =< T }{_:of x T'}.

%worlds (assm-b | tp-mode-always-safe) (of _ _) (used-neg _ _ _) (used-as-neg _ _ _ _).

=<-2-<m : A =< A' -> tp-mode A M -> tp-mode A' M' -> M <m M' -> type.
%mode =<-2-<m +A +B +C -D.
- :  =<-2-<m =</unit tp-mode/unit tp-mode/unit <m/e.
- :  =<-2-<m (=</~> _ _) tp-mode/~> tp-mode/~> <m/e.
- :  =<-2-<m (=</sum M _ _) tp-mode/sum tp-mode/sum M.
- : =<-2-<m (=</prod LL' RR') (tp-mode/prod lub/e L R) (tp-mode/prod Lub' L' R') MlC'
  <- =<-2-<m LL' L L' MlMl'
 <- lub-2-ub Lub' (ub/p Ml'C' _)
  <- <m-trans MlMl' Ml'C' MlC'.

- : =<-2-<m (=</prod LL' RR') (tp-mode/prod lub/pr L R) (tp-mode/prod Lub' L' R') MlC'
  <- =<-2-<m LL' L L' MlMl'
 <- lub-2-ub Lub' (ub/p Ml'C' _)
  <- <m-trans MlMl' Ml'C' MlC'.

- : =<-2-<m (=</prod LL' RR') (tp-mode/prod lub/pl L R) (tp-mode/prod Lub' L' R') MrC'
  <- =<-2-<m RR' R R' MrMr'
 <- lub-2-ub Lub' (ub/p _ Mr'C')
  <- <m-trans MrMr' Mr'C' MrC'.

%worlds (tp-mode-always-safe) (=<-2-<m _ _ _ _).
%total {A B C} (=<-2-<m A B C _).

=<-2-<m-s : A =< A' -> tp-mode-safe A M -> tp-mode-safe A' M' -> M <m M' -> type.
%mode =<-2-<m-s +A +B +C -D.

- :  =<-2-<m-s =</unit tp-mode-safe/unit tp-mode-safe/unit <m/e.
- :  =<-2-<m-s (=</~> _ _) (tp-mode-safe/~> _ _) (tp-mode-safe/~> _ _) <m/e.
- :  =<-2-<m-s (=</sum M _ _) (tp-mode-safe/sum _ _ _) (tp-mode-safe/sum _ _ _) M.
- : =<-2-<m-s (=</prod LL' RR') (tp-mode-safe/prod lub/e L R) (tp-mode-safe/prod Lub' L' R') MlC'
  <- =<-2-<m-s LL' L L' MlMl'
 <- lub-2-ub Lub' (ub/p Ml'C' _)
  <- <m-trans MlMl' Ml'C' MlC'.

- : =<-2-<m-s (=</prod LL' RR') (tp-mode-safe/prod lub/pr L R) (tp-mode-safe/prod Lub' L' R') MlC'
  <- =<-2-<m-s LL' L L' MlMl'
 <- lub-2-ub Lub' (ub/p Ml'C' _)
  <- <m-trans MlMl' Ml'C' MlC'.

- : =<-2-<m-s (=</prod LL' RR') (tp-mode-safe/prod lub/pl L R) (tp-mode-safe/prod Lub' L' R') MrC'
  <- =<-2-<m-s RR' R R' MrMr'
  <- lub-2-ub Lub' (ub/p _ Mr'C')
  <- <m-trans MrMr' Mr'C' MrC'.
%worlds (tp-b | tp-mode-always-safe) (=<-2-<m-s _ _ _ _).
%total {A B C} (=<-2-<m-s A B C _).

of-safe : of E T -> tp-mode-safe T M -> type.
%mode of-safe +Of -Safe.

- : of-safe of/empty tp-mode-safe/unit.
- : of-safe (of/obj OfL OfR) (tp-mode-safe/prod Lub TmsL TmsR) 
 <- of-safe OfR TmsR
 <- of-safe OfL TmsL
 <- has-lub _ _ _ Lub.
- : of-safe (of/getLeft _ _ OfProd) TmsL
 <- of-safe OfProd (tp-mode-safe/prod _ TmsL TmsR).
- : of-safe (of/getRight _ _ OfProd) TmsR
 <- of-safe OfProd (tp-mode-safe/prod _ TmsL TmsR).
- : of-safe (of/left Ub TmsA TmsB : of left (Ta ~> sum Ta Tb C)) (tp-mode-safe/~> TmsA (tp-mode-safe/sum Ub TmsA TmsB)).
- : of-safe (of/right Ub TmsA TmsB : of right (Tb ~> sum Ta Tb C)) (tp-mode-safe/~> TmsB (tp-mode-safe/sum Ub TmsA TmsB)).

- : of-safe (of/switch TmsC TmsA TmsB OfL OfR) (tp-mode-safe/~> (tp-mode-safe/sum (ub/p <m/e <m/e) TmsA TmsB) TmsC).

- : of-safe (of/logic-var Tms) Tms.

- : of-safe (of/subsump TmsT Sub OfT') TmsT.

- : of-safe (of/@s OfEf OfEv Sub) R
 <- of-safe OfEf (tp-mode-safe/~> _ R).

- : of-safe (of/lam FoOf TmsA TmsB (_ : used-neg F _ _)) (tp-mode-safe/~> TmsA TmsB).

%worlds (tp-mode-always-safe) (of-safe _ _).
%total {A} (of-safe A _).

not-val : tm -> type.
%mode not-val +A.
not-val/getLeft : not-val (getLeft _).
not-val/getRight : not-val (getRight _).
not-val/@s : not-val (@s _ _).
%worlds (tm-b) (not-val _).


=<-eq : {A} A =< A -> type.
%mode =<-eq +T -A.
=<-eq/unit : =<-eq unit =</unit.
=<-eq/~> : =<-eq (Ta ~> Tb) (=</~> A B) <- =<-eq Tb B <- =<-eq Ta A.
=<-eq/sum : =<-eq (sum Ta Tb _) (=</sum <m/e A B) 
         <- =<-eq Tb B 
         <- =<-eq Ta A.
=<-eq/prod : =<-eq (prod Ta Tb) (=</prod A B)  
          <- =<-eq Tb B 
          <- =<-eq Ta A.

%worlds () (=<-eq _ _).
%unique =<-eq +T -1A.
%total {A} (=<-eq A _).

eq-gen : {Eq : A =< A} =<-eq A Eq -> type.
%mode eq-gen +A -B.
%worlds () (eq-gen _ _).
%trustme %total {A} (eq-gen A _).

=<-trans : A =< B -> B =< C -> A =< C -> type. 
=<-trans' : B =< C -> A =< B -> A =< C -> type. 
%mode =<-trans +A +B -C.
%mode =<-trans' +A +B -C.
- : =<-trans =</unit =</unit =</unit.
- : =<-trans (=</~> AA' BB') (=</~> A'A'' B'B'') (=</~> AA'' BB'') <- =<-trans' AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</sum MM' AA' BB') (=</sum M'M'' A'A'' B'B'') (=</sum MM'' AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB'' <- <m-trans MM' M'M'' MM''. 
- : =<-trans (=</prod AA' BB') (=</prod A'A'' B'B'') (=</prod AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.

- : =<-trans' =</unit =</unit =</unit.
- : =<-trans' (=</~> A'A'' B'B'') (=</~> AA' BB') (=</~> AA'' BB'') <- =<-trans A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</sum M'M'' A'A'' B'B'') (=</sum MM' AA' BB') (=</sum MM'' AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB'' <- <m-trans MM' M'M'' MM''. 
- : =<-trans' (=</prod A'A'' B'B'') (=</prod AA' BB') (=</prod AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.

%block =<-eq-b' : some {A}{E:A =< A} block {_: =<-eq A E}.
%worlds (=<-eq-b') (=<-trans _ _ _) (=<-trans' _ _ _).
%unique (=<-trans +A +B -1C) (=<-trans' +A' +B' -1C').
%total (A B) (=<-trans A _ _) (=<-trans' B _ _).



step : tm -> tm -> type. %name step Step.

%mode step +A -B.

step/@s : step (@s E1 E2) (@s E1' E2)
       <- step E1 E1'.

step/lam : step (@s (lam V _) E) (V E).


step/getLeft : step (getLeft (obj L _)) L.

step/e : step A A.

step/getLeft-simp : step (getLeft A) (getLeft A')
                 <- not-val A 
                 <- step A A'.
             
step/getRight : step (getRight (obj _ R)) R.

step/getRight-simp : step (getRight A) (getRight A')
                  <- not-val A
                  <- step A A'.

step/switch-left  : step (@s (switch LF _) (@s left L)) (@s LF L).

step/switch-right : step (@s (switch _ RF) (@s right R)) (@s RF R).

%worlds (tm-b) (step _ _).


preservation : step E E' -> of E T -> of E T' -> T' =< T -> type.
%mode preservation +Step +T -T' -Sub.
%worlds () (preservation _ _ _ _).
%trustme %total {A B} (preservation A B _ _).


neg-is-top : A =< A' -> tp-mode A neg -> tp-mode A' neg -> type.
%mode neg-is-top +A +B -C. %worlds () (neg-is-top _ _ _).
%trustme %total {} (neg-is-top _ _ _).

pos-is-bot : A =< A' -> tp-mode A' pos -> tp-mode A pos -> type.
%mode pos-is-bot +A +B -C. %worlds () (pos-is-bot _ _ _).
%trustme %total {} (pos-is-bot _ _ _).


logic-less : of A T -> type. %name logic-less LL.
%mode logic-less +A.

logic-less/app-+ : logic-less (of/@s _ OfIe _ : of (@s Fe Ie) Bt)
		<- logic-less OfIe
		<- tp-mode-safe Bt pos.

% in this case, we simply don't care what happens.
logic-less/app++ : logic-less (of/@s _ _ (_ : _ =< At) : of (@s Fe Ie) Bt)
                <- tp-mode-safe Bt pos
                <- tp-mode-safe At pos.

logic-less/app : logic-less (of/@s OfFe OfIe _)
              <- logic-less OfIe
              <- logic-less OfFe.

logic-less/lam : logic-less (of/lam F _ _ _) 
              <- {x}{t'}{s}{OfXt' : of x t'} logic-less OfXt' -> logic-less (F x t' s OfXt').

logic-less/empty : logic-less of/empty.
logic-less/obj : logic-less (of/obj OfA OfB) 
              <- logic-less OfB 
              <- logic-less OfA.


logic-less/getLeft : logic-less OfA -> logic-less (of/getLeft _ _ OfA).

logic-less/getRight : logic-less OfA -> logic-less (of/getRight _ _ OfA).

logic-less/left : logic-less (of/left _ _ _).
logic-less/right : logic-less (of/right _ _ _).

%{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Some lemmas for unpacking and effectiveness
}%

used-as-neg-2-logic-less : {OfET : of E T} used-as-neg Result T E E' -> of E' T' -> tp-mode-safe T' pos -> logic-less OfET -> type.
%mode used-as-neg-2-logic-less +OfET +UsedAsNeg +Of +Pos -LogicLess.

%worlds () (used-as-neg-2-logic-less _ _ _ _ _).
%trustme %total {O A B C} (used-as-neg-2-logic-less O A B C _).


%{ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

we need step and  "logic-less Be"
so that we know that Ae, despite being positively moded is actually 
free of logic variables by having progress.  
The existence of logic variables should hinder progress in a positively moded "thing"
so the existence of progress should imply no logic variables.

Since the existence of progress implies no logic variables, 
then the A that "findAll F" returns 
(where A is such that "step (F A) Success" and F returns positive and success contains no logic variables) 
must also contain no logic variables.

i think (@s (A: _/+ ~> _/+) (B : _/-) _) : _/- for this all to work.  which is an odd exception case, 
more accurately, "+ ~> +" is actually "- ~> -"
but corresponds to not actually being negative. that, or no right hand side steps. 
that InputIsPos is an argument to resolving why we need this stuff.
so we need a lemma that says (F I: A/+) => F:R/+ ~> O/+ => I:R/+.

}%

resolving : {OfAeAt: of Ae At}
	    step Ae Be
         -> {OfBeBt: of Be Bt}
	    Bt =< At
         -> tp-mode-safe At pos
         -> logic-less OfBeBt
         -> logic-less OfAeAt
         -> type.

- : resolving _ step/e _ _ _ A A. 

0 : resolving _ (_ : step (@s E1 _) (@s E1 _)) _ _ _ (logic-less/app++ Arg_Pos Arg_Neg) (logic-less/app++ Arg_Pos Arg_Neg).

% 1 : resolving (step/obj-simp _ Simp) Init_Result_Pos LogicLessLeft (logic-less/lr-lazy LogicLessLeft Simp).

2p0 : resolving (step/getLeft-simp Step NotValE1) Lpos (logic-less/getLeft LogicLessObj) (logic-less/getLeft LogicLessObj')
   <- resolving Step (tp-mode/prod lub/e) LogicLessObj (LogicLessObj' : logic-less L).

4 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
5 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).
6 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).

7 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
8 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).
9 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).

10 : resolving (step/@s _ StepE1tE1') Init_Result_Pos (logic-less/app LLFe LLIe) (logic-less/app LLFe' LLIe) 
  <- resolving StepE1tE1' tp-mode/~> LLFe LLFe'.

11 : resolving
      (step/@s Trans Step)
      Init_Result_Pos
      (logic-less/app-+ Init_Result_Pos' LLIe)
      (logic-less/app-+ Init_Result_Pos LLIe).

%% somehow the positivity of the result, 
%% and the positivity of the first argument imply the non check of the logic-less

12 : resolving 
     (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) _ TmB B'eB) : step (@s (lam V (used-neg/+* Arg_Is_Pos)) E S) TmB B'eB)
     Init_Result_Pos
     LogicLessTmB
     (logic-less/app++ Arg_Is_Pos Init_Result_Pos).

% might need to prove an equality lemma for GetSubRes.
13 : resolving
      (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) B' TmB B'eB) 
        : step (@s (lam V (used-neg/-+ ProveUsedAsNeg Arg_Is_Neg _)) _ _) _ _)
      Init_Result_Pos
      LogicLessTmB
      (logic-less/app-+ Init_Result_Pos LogicLessE)
  <- unpack-used-as-neg' (ProveUsedAsNeg (subRes/dual T E S) T E S getSubRes/get) UsedAsNeg
  <- used-as-neg-2-logic-less UsedAsNeg Init_Result_Pos LogicLessE.



% "ProveUsedAsNeg T S E E_Is_Neg" should show that "logic-less E"
% somehow we also would need E_Is_Neg or at least, E could be Neg.
% to get E_Is_Neg, we need to know that the input is Neg for logic-less.
% perhaps LogicLessTmB should be entered?  (or not, it feels a bit weird doing that).


%worlds () (resolving _ _ _ _).
%mode resolving +A +B +C -D.
%total {A B} (resolving A _ B _).
