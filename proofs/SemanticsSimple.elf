% twelf-server-send-command "set unsafe true"
%%%%%%%%%%%%%%%%%%%%%%%%
% what resolvedness is %
%%%%%%%%%%%%%%%%%%%%%%%%
mode : type. %name mode Gs.
%mode mode.
pos : mode.
neg : mode.
%block m-b : block {_ : mode}.
%worlds (m-b) (mode).
%freeze mode.


<m : mode -> mode -> type. %infix right 5 <m.  %name <m SubM.
%mode <m +A +B. 
<m/e : A <m A.
<m/pn : pos <m neg.
%block <m-b/<m : some {A : mode}{B : mode} block {_:A <m B}.
%block <m-b = (<m-b/<m | m-b).
%worlds (<m-b) (<m _ _).

ub : mode -> mode -> mode -> type.  %name ub UB.
ub/p : A <m C -> B <m C -> ub A B C.
%block ub-b/ub : some {A}{B}{C} block {_ : ub A B C}.
%block ub-b = (<m-b | ub-b/ub).
%worlds (ub-b) (ub _ _ _).
%freeze ub.

lub : mode -> mode -> mode -> type. %name lub LUB. 
%mode lub +A +B -C.  
lub/e : lub A A A.
lub/pl : lub pos neg neg.
lub/pr : lub neg pos neg.

%worlds () (lub _ _ _). 
%unique lub +A +B -1C.
%total {A B} (lub A B _).
%freeze lub.

glb : mode -> mode -> mode -> type. %name glb GLB.
%mode glb +A +B -C. 
glb/e : glb A A A.
glb/pl : glb pos neg pos.
glb/pr : glb neg pos pos.
%worlds () (glb _ _ _). 
%unique glb +A +B -1C.
%total {A B} (glb A B _).
%freeze glb. 

mode-sub-trans : A <m B -> B <m C -> A <m C -> type.
%mode mode-sub-trans +A +B -C.
mode-sub-trans/e :  mode-sub-trans <m/e A A.
mode-sub-trans/pn : mode-sub-trans <m/pn <m/e <m/pn.
%worlds (m-b | ub-b/ub) (mode-sub-trans _ _ _).
%unique mode-sub-trans +A +B -1C.
%total {A B} (mode-sub-trans A B _).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the types in the language %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tp : type. %name tp T t.
tp-mode : tp -> mode -> type. %name tp-mode TpM tpM.
%mode tp-mode +A -B.

~> : tp -> tp -> tp. %infix right 6 ~>.
unit : tp.
sum : tp-mode Ta A -> tp-mode Tb B -> ub A B C -> tp.
prod : tp-mode Ta A -> tp-mode Tb B -> tp.  

tp-mode/~> : tp-mode (B ~> A) pos.
tp-mode/unit : tp-mode unit pos.
tp-mode/sum : tp-mode (sum _ _ (_ : ub _ _ C)) C.
tp-mode/prod : tp-mode (prod (_ : tp-mode _ A) (_ : tp-mode _ B)) C <- lub A B C.


=< : tp -> tp -> type. %infix right 5 =<.
%mode =< +A +B.
=</unit : unit =< unit.
=</~> : A' =< A -> B =< B' -> (A ~> B) =< (A' ~> B').
=</sum :  M <m M'
       -> A =< A'
       -> B =< B'
       -> (sum (_ : tp-mode A _) (_ : tp-mode B _) (_ : ub _ _ M)) =< (sum (_ : tp-mode A' _) (_ : tp-mode B' _) (_ : ub _ _ M')).
=</prod :  A =< A'
        -> B =< B'
        -> (prod (_ : tp-mode A _) (_ : tp-mode B _)) =< (prod (_ : tp-mode A' _) (_ : tp-mode B' _)).

%block tp-b/s : some {T}{M} block {_: tp-mode T M}.
%block tp-b/moded : some  {M : mode} block {T : tp}{_ : tp-mode T M}.
%block tp-b = (tp-b/moded | ub-b/ub | <m-b/<m).
%block =<-bn : some {A}{A'} block {_ : A' =< A}.
%block =<-b = ( =<-bn | tp-b).
%worlds (=<-b) (tp-mode _ _) (=< _ _).
%unique tp-mode +A -1B.
%total {A} (tp-mode A _).

=<-eq : {A} A =< A -> type.
=<-eq/unit : =<-eq unit =</unit.
=<-eq/~> : =<-eq (Ta ~> Tb) (=</~> A B) <- =<-eq Tb B <- =<-eq Ta A.
=<-eq/sum : =<-eq (sum (_: tp-mode Ta _) (_ : tp-mode Tb _) _) (=</sum <m/e A B) 
         <- =<-eq Tb B 
         <- =<-eq Ta A.
=<-eq/prod : =<-eq (prod (_: tp-mode Ta _) (_ : tp-mode Tb _)) (=</prod A B)  
          <- =<-eq Tb B 
          <- =<-eq Ta A.
%mode =<-eq +T -A.
%worlds (=<-bn) (=<-eq _ _).
%unique =<-eq +T -1A.
%total {A} (=<-eq A _).


eq-gen : {Eq : A =< A} =<-eq A Eq -> type.
%mode eq-gen +A -B.
%worlds () (eq-gen _ _).
%trustme %total {A} (eq-gen A _).

=<-trans : A =< B -> B =< C -> A =< C -> type. 
=<-trans' : B =< C -> A =< B -> A =< C -> type. 
%mode =<-trans +A +B -C.
%mode =<-trans' +A +B -C.
- : =<-trans =</unit =</unit =</unit.
- : =<-trans (=</~> AA' BB') (=</~> A'A'' B'B'') (=</~> AA'' BB'') <- =<-trans' AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</sum MM' AA' BB') (=</sum M'M'' A'A'' B'B'') (=</sum MM'' AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans (=</prod AA' BB') (=</prod A'A'' B'B'') (=</prod AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.

- : =<-trans' =</unit =</unit =</unit.
- : =<-trans' (=</~> A'A'' B'B'') (=</~> AA' BB') (=</~> AA'' BB'') <- =<-trans A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</sum M'M'' A'A'' B'B'') (=</sum MM' AA' BB') (=</sum MM'' AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans' (=</prod A'A'' B'B'') (=</prod AA' BB') (=</prod AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.

%block =<-eq-b' : some {A}{E:A =< A} block {_: =<-eq A E}.
%worlds (m-b | ub-b/ub | tp-b/s | tp-b/moded | =<-eq-b') (=<-trans _ _ _) (=<-trans' _ _ _).
%unique (=<-trans +A +B -1C) (=<-trans' +A' +B' -1C').
%total (A B) (=<-trans A _ _) (=<-trans' B _ _).

=<implies<m : A =< A' -> tp-mode A M -> tp-mode A' M' -> M <m M' -> type.

%freeze =<implies<m.


% The definition of a tm (again)
% and other stuff with progress theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tm : tp -> type. %name tm E.

subRes : tp -> type.

subRes/dual : {B} tm B -> B =< B'  -> subRes B'.

getSubRes : subRes B' -> {B} tm B -> B =< B' -> type.
%mode getSubRes +A -B -C -D.
getSubRes/get : getSubRes (subRes/dual B TmB BsB') B TmB BsB'.

used-neg : (subRes A ->  subRes B) -> type.
%mode used-neg +A.


lam : {F : subRes A -> subRes B } used-neg F -> tm (A ~> B).
empty : tm unit.
obj : tm A -> tm B -> tm (prod (A_m_Ma : tp-mode A _) (B_m_Mb : tp-mode B _)).
getLeft : tm (prod (A_m_M : tp-mode A M) (_ : tp-mode _ M)) -> tm A.
getRight : tm (prod (_ : tp-mode _ M) (B_m_M : tp-mode B M)) -> tm B.
left : tm (A ~> sum (_ : tp-mode A _) _ _).
right : tm (B ~> sum _ (_ : tp-mode B _) _).
% switch should be GLB not LUB, but right now just making them equal seems good enough.
switch : tm (A ~> C) 
      -> tm (B ~> C) 
      -> tm (sum (_ : tp-mode A MC) (_ : tp-mode B MC) (_ : ub _ _ MC) ~> C).
logic-var : tp-mode B neg -> tm B.
@s : tm (A ~> C) -> tm A' -> A' =< A -> tm C.


used-as-neg : {Result : mode } tm A -> tm B -> type.
%mode used-as-neg +R +A +B.

used-as-neg' : {Result : mode } tm A -> subRes B -> type.
%mode used-as-neg' +R +A +B.
used-as-neg'/eval : used-as-neg' Result A SubResB 
                 <- getSubRes SubResB _ TmB _
                 <- used-as-neg Result A TmB.

used-neg/+* : used-neg (L : subRes T -> subRes R) 
            <- tp-mode T pos.
used-neg/-- : used-neg (L : subRes T -> subRes R) 
	    <- tp-mode R neg
	    <- tp-mode T neg
	    <- ({S}{t'}{a}{s} getSubRes S t' a s -> used-as-neg' neg a (L S)).
used-neg/-+ : used-neg (L : subRes T -> subRes R) 
	    <- tp-mode R pos
	    <- tp-mode T neg
	    <- ({S}{t'}{a}{s} getSubRes S t' a s -> used-as-neg' pos a (L S)).

used-as-neg/e : used-as-neg neg (A : tm T) A.
used-as-neg/lam-inner : ({S} used-as-neg' ResM A (F S)) 
		      -> used-as-neg ResM A (lam F _).

used-as-neg/app-l : used-as-neg ResM A E1 
                 -> used-as-neg ResM A (@s E1 E2 _).
used-as-neg/app-r : tp-mode T1 neg
                 -> used-as-neg neg A E2
                 -> used-as-neg ResM A (@s (E1 : tm (T1 ~> T2)) (E2 : tm T1') _).

used-as-neg/objL : used-as-neg ResM A L 
		-> tp-mode To neg
                -> used-as-neg ResM A (obj (L : tm To) R).

used-as-neg/objR : used-as-neg ResM A R 
		-> tp-mode To neg
                -> used-as-neg ResM A (obj L (R  : tm To)).

used-as-neg/product : used-as-neg ResM (getLeft A) E 
                   -> used-as-neg ResM (getRight A) E 
                   -> used-as-neg ResM A E.

used-as-neg/sum-unused : used-as-neg ResM A L1 
                       -> used-as-neg ResM A L2 
                       -> used-as-neg ResM A (switch L1 L2).


%block tp-introduce-b : some {A} block {S : subRes A}{t'}{a}{s}{_:getSubRes S t' a s}.
%block tp-introduce-last : some {A}{M} block {S : tp-mode A M}.
%trustme %worlds (tp-introduce-b | tp-introduce-last) (tm _) (used-as-neg _ _ _) (used-as-neg' _ _ _) (used-neg _) (subRes _) (getSubRes _ _ _ _).

%total {A} (getSubRes A _ _ _).

obj-simp : tm T -> tm T -> type.
%mode obj-simp +A -B.
obj-simp/el : obj-simp (getLeft (obj L _)) L.
obj-simp/er : obj-simp (getRight (obj _ R)) R.
obj-simp/l : obj-simp (getLeft O) L <- obj-simp O (obj  L _).
obj-simp/r : obj-simp (getRight O) R <- obj-simp O (obj _ R).
obj-simp/concat : obj-simp A C <- obj-simp A B <- obj-simp B C.
%worlds () (obj-simp _ _).

concat-obj-simp/l : obj-simp A B -> obj-simp (getLeft B) C -> obj-simp (getLeft A) C -> type.
%mode concat-obj-simp/l +A +B -C.
%worlds () (concat-obj-simp/l _ _ _).
%trustme %total {A B} (concat-obj-simp/l A B _).

not-val : tm A -> type.
%mode not-val +A.
not-val/getLeft : not-val (getLeft _).
not-val/getRight : not-val (getRight _).
not-val/@s : not-val (@s _ _ _).
%worlds () (not-val _).




step : tm A -> tm A' -> A' =< A -> type. %name step Step.

%mode step +A -B -C.

step/@s : step (@s E1 E2 A'eA) (@s E1' E2 A'eA'') B'eB
       <- step E1 E1' (=</~> AeA'' B'eB)
       <- =<-trans A'eA AeA'' A'eA''.

step/lam : step (@s (lam V _) (E : tm T) S) TmB (B'eB : B' =< B) 
        <- getSubRes (V (subRes/dual T E S)) B' TmB B'eB.


step/getLeft : step (getLeft (obj L _)) (L : tm Lt) Eq <- =<-eq Lt Eq.

step/e : step A A Eq <- =<-eq T Eq.

step/obj-simp : step A A' Eq
             <- obj-simp A (A' : tm T)
             <- =<-eq T Eq.
step/getLeft-simp : step (getLeft A) (getLeft A') L'eL 
                 <- not-val A 
                 <- step A A' (=</prod L'eL _).
             
step/getRight : step (getRight (obj _ R)) (R : tm Rt) Eq <- =<-eq Rt Eq.

step/getRight-simp : step (getRight A) (getRight A') R'eR 
                  <- not-val A
                  <- step A A' (=</prod _ R'eR).

step/switch-left  : step (@s (switch (LF : tm (_ ~> ResT)) _) (@s left L LeP) (=</sum _ PeL' _)) (@s LF L LeL') Eq
                 <- =<-trans LeP PeL' LeL'
                 <- =<-eq ResT Eq.

step/switch-right : step (@s (switch _ (RF : tm (_ ~> ResT))) (@s right R ReP) (=</sum _ _ PeR')) (@s RF R ReR') Eq
                <- =<-trans ReP PeR' ReR'
                 <- =<-eq ResT Eq.

%worlds () (step _ _ _).


neg-is-top : A =< A' -> tp-mode A neg -> tp-mode A' neg -> type.
%mode neg-is-top +A +B -C. %worlds () (neg-is-top _ _ _).
%trustme %total {} (neg-is-top _ _ _).

pos-is-bot : A =< A' -> tp-mode A' pos -> tp-mode A pos -> type.
%mode pos-is-bot +A +B -C. %worlds () (pos-is-bot _ _ _).
%trustme %total {} (pos-is-bot _ _ _).




logic-less : tm A -> type. %name logic-less LL.
logic-less' : subRes A -> type. %name logic-less' LL'.
logic-less'/get : logic-less' Sub <- getSubRes Sub _ TmB _ <- logic-less TmB.
%mode (logic-less +A) (logic-less' +A). 


logic-less/app-+ : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
               <- logic-less Ie
               <- tp-mode Bt pos.

% in this case, we simply don't care what happens.
logic-less/app++ : logic-less (@s (Fe : tm (At ~> Bt)) _ _) 
                <- tp-mode Bt pos
                <- tp-mode At pos.

logic-less/app : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
              <- logic-less Ie
              <- logic-less Fe.

logic-less/lam : logic-less (lam F _) 
              <- {S}{t'}{a}{s} getSubRes S t' a s -> logic-less a -> logic-less' (F S).

logic-less/empty : logic-less empty.
logic-less/obj : logic-less (obj A B) 
              <- logic-less B 
              <- logic-less A.


logic-less/getLeft : logic-less A -> logic-less (getLeft A).

logic-less/getRight : logic-less A -> logic-less (getRight A).
%{
logic-less/lr-lazy : logic-less A
                  <- obj-simp A V
                  <- logic-less V.
}%
logic-less/left : logic-less left.
logic-less/right : logic-less right.

%{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Some lemmas for unpacking and effectiveness
}%

%% unpacking lemma for used-as-neg
unpack-used-as-neg' : used-as-neg' Res TmA SubResB -> used-as-neg Res TmA TmB -> type.
%mode unpack-used-as-neg' +UaN' -R.
- : unpack-used-as-neg' (used-as-neg'/eval UsedAsNegATmB getSubRes/get) UsedAsNegATmB.
%worlds () (unpack-used-as-neg' _ _).
%unique unpack-used-as-neg' +A -1C.
%total {A} (unpack-used-as-neg' A _).





used-as-neg-2-logic-less : used-as-neg Res E (B : tm T) -> tp-mode T pos -> logic-less E -> type.
%mode used-as-neg-2-logic-less +UsedAsNeg +Pos -LogicLess.


%worlds () (used-as-neg-2-logic-less _ _ _).
%trustme %total {A B} (used-as-neg-2-logic-less A B _).




%{ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

we need step and  "logic-less Be"
so that we know that Ae, despite being positively moded is actually 
free of logic variables by having progress.  
The existence of logic variables should hinder progress in a positively moded "thing"
so the existence of progress should imply no logic variables.

Since the existence of progress implies no logic variables, 
then the A that "findAll F" returns 
(where A is such that "step (F A) Success" and F returns positive and success contains no logic variables) 
must also contain no logic variables.

i think (@s (A: _/+ ~> _/+) (B : _/-) _) : _/- for this all to work.  which is an odd exception case, 
more accurately, "+ ~> +" is actually "- ~> -"
but corresponds to not actually being negative. that, or no right hand side steps. 
that InputIsPos is an argument to resolving why we need this stuff.
so we need a lemma that says (F I: A/+) => F:R/+ ~> O/+ => I:R/+.

}%

resolving : step (Ae : tm At) Be _
         -> tp-mode At pos
         -> logic-less Be
         -> logic-less Ae
         -> type.

- : resolving (step/e _) _ A A. 

0 : resolving (_ : step (@s E1 _ _) (@s E1 _ _) _) _ (logic-less/app++ Arg_Pos Arg_Neg) (logic-less/app++ Arg_Pos Arg_Neg).

% 1 : resolving (step/obj-simp _ Simp) Init_Result_Pos LogicLessLeft (logic-less/lr-lazy LogicLessLeft Simp).
%{
1 : resolving (step/getLeft _ : step (getLeft (obj L (R: tm Rt))) L _) Init_Result_Pos LL_L (logic-less/getLeft (logic-less/obj LL_L LL_R))
 <- tp-mode Rt neg
 <- tp-mode T pos
 <- used-as-neg pos (obj L R) (E : tm T)
 <- resolving _ _ _ _.
 }%



2p0 : resolving (step/getLeft-simp Step NotValE1) Lpos (logic-less/getLeft LogicLessObj) (logic-less/getLeft LogicLessObj')
   <- resolving Step (tp-mode/prod lub/e) LogicLessObj (LogicLessObj' : logic-less L).


%{
2p1 : resolving 
       (step/getLeft-simp 
	  (step/lam _)
	  (not-val/@s : not-val (@s (lam F (used-neg/-+ UsedAsNegFoo _ ResultPos)) (V : tm T) S)))
       Lpos
       (logic-less/lr-lazy _ _)
       (logic-less/getLeft (logic-less/app-+ ResultPos LogicLessV)) 
    <- unpack-used-as-neg' (UsedAsNegFoo T S V) UsedAsNeg
    <- used-as-neg-2-logic-less UsedAsNeg Lpos LogicLessV.

2p2 : resolving 
       (step/getLeft-simp (step/lam _) (not-val/@s : not-val (@s (lam _ (used-neg/+* ArgPos)) _ _))) 
       Lpos 
       (logic-less/lr-lazy _ _)
       (logic-less/getLeft (logic-less/app++ ArgPos (tp-mode/prod lub/e))).

2p3 : resolving
       (step/getLeft-simp (step/obj-simp Eq Simp) _)
       (Init_Result_Pos : tp-mode Lt pos)
       (logic-less/lr-lazy LL_L Simp' ) % : logic-less (getLeft IMB))
       (logic-less/lr-lazy LL_L Simp'' ) % : logic-less (getLeft (getLeft IMB')))
   <- concat-obj-simp/l Simp Simp' Simp''.

% (obj-simp/l Simp') : obj-simp (getLeft (getLeft E2)) E3

% LL_L : logic-less E3


   


2p4 : resolving
       (step/getLeft-simp Step _)
       Init_Result_Pos
       (logic-less/lr-lazy LL_L (obj-simp/l S))
       (logic-less/getLeft LL)
   <- {LL_R} resolving Step (tp-mode/prod lub/e) (logic-less/obj LL_L LL_R) LL. 
}%


4 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
5 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).
6 : resolving (step/switch-left _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/left Ie)).

7 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Init_Result_Pos _ (logic-less/app++ tp-mode/sum Init_Result_Pos).
8 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app-+ Init_Result_Pos Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).
9 : resolving (step/switch-right _ _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Init_Result_Pos
              (logic-less/app _ Ie)
              (logic-less/app-+ Init_Result_Pos (logic-less/app logic-less/right Ie)).

10 : resolving (step/@s _ StepE1tE1') Init_Result_Pos (logic-less/app LLFe LLIe) (logic-less/app LLFe' LLIe) 
  <- resolving StepE1tE1' tp-mode/~> LLFe LLFe'.

11 : resolving
      (step/@s Trans Step)
      Init_Result_Pos
      (logic-less/app-+ Init_Result_Pos' LLIe)
      (logic-less/app-+ Init_Result_Pos LLIe).

%% somehow the positivity of the result, 
%% and the positivity of the first argument imply the non check of the logic-less

12 : resolving 
     (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) _ TmB B'eB) : step (@s (lam V (used-neg/+* Arg_Is_Pos)) E S) TmB B'eB)
     Init_Result_Pos
     LogicLessTmB
     (logic-less/app++ Arg_Is_Pos Init_Result_Pos).

% might need to prove an equality lemma for GetSubRes.
13 : resolving
      (step/lam (GetSubRes : getSubRes (V (subRes/dual T E S)) B' TmB B'eB) 
        : step (@s (lam V (used-neg/-+ ProveUsedAsNeg Arg_Is_Neg _)) _ _) _ _)
      Init_Result_Pos
      LogicLessTmB
      (logic-less/app-+ Init_Result_Pos LogicLessE)
  <- unpack-used-as-neg' (ProveUsedAsNeg (subRes/dual T E S) T E S getSubRes/get) UsedAsNeg
  <- used-as-neg-2-logic-less UsedAsNeg Init_Result_Pos LogicLessE.



% "ProveUsedAsNeg T S E E_Is_Neg" should show that "logic-less E"
% somehow we also would need E_Is_Neg or at least, E could be Neg.
% to get E_Is_Neg, we need to know that the input is Neg for logic-less.
% perhaps LogicLessTmB should be entered?  (or not, it feels a bit weird doing that).


%worlds () (resolving _ _ _ _).
%mode resolving +A +B +C -D.
%total {A B} (resolving A _ B _).

%{

WHYY is this causing server timeouts?  its very clearly an error given that step/getLeft takes no arguments

2p3 : resolving 
       (step/getLeft-simp Step not-val/getLeft)
       Lpos
       (logic-less/getLeft-lazy LogicLessLeft)
       _
   <- resolving (step/getLeft Step) (tp-mode/prod lub/e) LogicLessLeft LogicLessObj.

}%