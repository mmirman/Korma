%%%%%%%%%%%%%%%%%%%%%%%%
% what resolvedness is %
%%%%%%%%%%%%%%%%%%%%%%%%
mode : type.
pos : mode.
neg : mode.
%mode mode.
%freeze mode.
%name mode Gs.

<m : mode -> mode -> type. %infix right 5 <m.
%mode <m +A +B.
<m/e : A <m A.
<m/pn : pos <m neg.

ub : mode -> mode -> mode -> type.
ub/p : A <m C -> B <m C -> ub A B C.
%freeze ub. %name ub UB.

lub : mode -> mode -> mode -> type.
lub/e : lub A A A.
lub/pl : lub pos neg neg.
lub/pr : lub neg pos neg.
%mode lub +A +B -C.
%worlds () (lub _ _ _). 
%unique lub +A +B -1C.
%total {A B} (lub A B _).
%freeze lub. %name lub LUB.

glb : mode -> mode -> mode -> type.
glb/e : glb A A A.
glb/pl : glb pos neg pos.
glb/pr : glb neg pos pos.
%mode glb +A +B -C.
%worlds () (glb _ _ _). 
%unique glb +A +B -1C.
%total {A B} (glb A B _).
%freeze glb. %name glb GLB.

mode-sub-trans : A <m B -> B <m C -> A <m C -> type.
%mode mode-sub-trans +A +B -C.
mode-sub-trans/e :  mode-sub-trans <m/e A A.
mode-sub-trans/pn : mode-sub-trans <m/pn <m/e <m/pn.
%worlds () (mode-sub-trans _ _ _).
%unique mode-sub-trans +A +B -1C.
%total {A B} (mode-sub-trans A B _).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the types in the language %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tp : type.
tp-mode : tp -> mode -> type.
%mode tp-mode +A -B.

~> : tp -> tp -> tp. %infix right 6 ~>.
unit : tp.
sum : tp-mode Ta A -> tp-mode Tb B -> ub A B C -> tp.
%% should make this lub and not ub- infact, it could get removed all together 
prod : tp-mode Ta A -> tp-mode Tb B -> tp.  

tp-mode/~> : tp-mode (B ~> A) pos.
tp-mode/unit : tp-mode unit pos.
tp-mode/sum : tp-mode (sum _ _ (_ : ub _ _ C)) C.
tp-mode/prod : tp-mode (prod (_ : tp-mode _ A) (_ : tp-mode _ B)) C <- lub A B C.
%worlds () (tp-mode _ _).
%unique tp-mode +A -1B.
%total {} (tp-mode _ _).
%name tp-mode TM.
%name tp T t.

=< : tp -> tp -> type. %infix right 5 =<.
%mode =< +A +B.
=</e : A =< A.
=</~> : A' =< A -> B =< B' -> (A ~> B) =< (A' ~> B').
=</sum :  M <m M'
       -> A =< A'
       -> B =< B'
       -> (sum (_ : tp-mode A _) (_ : tp-mode B _) (_ : ub _ _ M)) =< (sum (_ : tp-mode A' _) (_ : tp-mode B' _) (_ : ub _ _ M')).
=</prod :  A =< A'
        -> B =< B'
        -> (prod (_ : tp-mode A _) (_ : tp-mode B _)) =< (prod (_ : tp-mode A' _) (_ : tp-mode B' _)).

=<-trans : A =< B -> B =< C -> A =< C -> type. 
=<-trans' : B =< C -> A =< B -> A =< C -> type. 

%mode =<-trans +A +B -C.
%mode =<-trans' +A +B -C.
- : =<-trans =</e A A.
- : =<-trans (=</~> AA' BB') (=</~> A'A'' B'B'') (=</~> AA'' BB'') <- =<-trans' AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</sum MM' AA' BB') (=</sum M'M'' A'A'' B'B'') (=</sum MM'' AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans (=</prod AA' BB') (=</prod A'A'' B'B'') (=</prod AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</~> AA' BB') =</e (=</~> AA' BB').
- : =<-trans (=</sum MM' AA' BB') =</e (=</sum MM' AA' BB').
- : =<-trans (=</prod AA' BB') =</e (=</prod AA' BB').

- : =<-trans' =</e A A.
- : =<-trans' (=</~> A'A'' B'B'') (=</~> AA' BB') (=</~> AA'' BB'') <- =<-trans A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</sum M'M'' A'A'' B'B'') (=</sum MM' AA' BB') (=</sum MM'' AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans' (=</prod A'A'' B'B'') (=</prod AA' BB') (=</prod AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</~> AA' BB') =</e (=</~> AA' BB').
- : =<-trans' (=</sum MM' AA' BB') =</e (=</sum MM' AA' BB').
- : =<-trans' (=</prod AA' BB') =</e (=</prod AA' BB').
%worlds () (=<-trans _ _ _) (=<-trans' _ _ _).
%unique (=<-trans +A +B -1C) (=<-trans' +A' +B' -1C').
%total (A B) (=<-trans A _ _) (=<-trans' B _ _).


~< : tp -> tp -> type. %infix right 5 ~<.
%mode ~< +A +B.
~</e : A ~< A.
~</~> : (A ~> B) =< (A' ~> B') -> (A ~> B) ~< (A' ~> B').
~</sum : A ~< A' 
       -> B ~< B'
       -> (sum (_ : tp-mode A _) (_ : tp-mode B _) _) ~< (sum (_ : tp-mode A' _) (_ : tp-mode B' _) _).
~</prod : A ~< A' 
        -> B ~< B' 
        -> (prod (_ : tp-mode A _) (_ : tp-mode B _)) ~< (prod (_ : tp-mode A' _) (_ : tp-mode B' _)).


promote : A =< B -> A ~< B -> type.
%mode promote +A -B.
- : promote =</e ~</e.
- : promote (=</~> A B) (~</~> (=</~> A B)).
- : promote (=</sum _ A B) (~</sum A' B') <- promote A A' <- promote B B'.
- : promote (=</prod A B) (~</prod A' B') <- promote A A' <- promote B B'.
%worlds () (promote _ _).
%unique promote +A -1B.
%total (A) (promote A _).


~<-trans : A ~< B -> B ~< C -> A ~< C -> type. 
%mode ~<-trans +A +B -C.
- : ~<-trans ~</e A A.
- : ~<-trans (~</~> AA') (~</~> A'A'') (~</~> AA'') <- =<-trans AA' A'A'' AA''.
- : ~<-trans (~</sum AA' BB') (~</sum A'A'' B'B'') (~</sum AA'' BB'') <- ~<-trans AA' A'A'' AA'' <- ~<-trans BB' B'B'' BB'' . 
- : ~<-trans (~</prod AA' BB') (~</prod A'A'' B'B'') (~</prod AA'' BB'') <- ~<-trans AA' A'A'' AA'' <- ~<-trans BB' B'B'' BB'' . 
- : ~<-trans (~</~> AA') ~</e (~</~> AA').
- : ~<-trans (~</sum AA' BB') ~</e (~</sum AA' BB').
- : ~<-trans (~</prod AA' BB') ~</e (~</prod AA' BB').
%worlds () (~<-trans _ _ _).
%unique ~<-trans +A +B -1C.
%total {A B} (~<-trans A B _).


% The definition of a tm (again)
% and other stuff with progress theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tm : tp -> type.
used-as-neg : tm A -> tm B -> type.
used-neg : mode -> (tm A -> tm B) -> type.



lam : {F : tm A -> tm B } tp-mode A M -> used-neg M F -> tm (A ~> B).
empty : tm unit.
is_empty : tm (unit ~> unit).
obj : tm A -> tm B -> tm (prod (A_m_Ma : tp-mode A _) (B_m_Mb : tp-mode B _)).
getLeft : tm (prod (A_m_Ma : tp-mode A M) (_ : tp-mode _ M) ~> A).
getRight : tm (prod (_ : tp-mode _ M) (B_m_Mb : tp-mode B _) ~> B).
left : tm (A ~> sum (_ : tp-mode A _) _ _).
right : tm (B ~> sum _ (_ : tp-mode B _) _).
% switch should be GLB not LUB, but right now just making them equal seems good enough.
switch : tm (A ~> C) 
      -> tm (B ~> C) 
      -> tm (sum (_ : tp-mode A MC) (_ : tp-mode B MC) (_ : ub _ _ MC) ~> C).
logic-var : tp-mode B neg -> tm B.
@s : tm (A ~> C) -> tm A' -> A' ~< A -> tm C.
%name tm E.

used-neg/pos : used-neg pos L.
used-neg/neg : ({a : tm A} tp-mode A neg -> used-as-neg a (L a)) -> used-neg neg L.

used-as-neg/e : tp-mode T neg -> used-as-neg (A : tm T) A.
used-as-neg/lam-inner : ({e} used-as-neg A (F e)) -> used-as-neg A (lam F _ _).
used-as-neg/app-l : used-as-neg A E1 -> used-as-neg A (@s E1 E2 _).
used-as-neg/app-r : tp-mode T1 neg -> tp-mode T1' neg -> used-as-neg A E2 -> used-as-neg A (@s (E1 : tm (T1 ~> T2)) (E2 : tm T1') _).

used-as-neg/objL : used-as-neg A L 
		-> tp-mode To neg
                -> used-as-neg A (obj (L : tm To) R).

used-as-neg/objR : used-as-neg A R 
		-> tp-mode To neg
                -> used-as-neg A (obj L (R  : tm To)).

used-as-neg/product : used-as-neg (@s getLeft A _) E 
                   -> used-as-neg (@s getRight A _) E 
                   -> used-as-neg A E.

used-as-neg/sum-unused : used-as-neg A L1 
                       -> used-as-neg A L2 
                       -> used-as-neg A (switch L1 L2).


step : tm A -> tm A' -> A' ~< A -> type.
%mode step +A -B -C.

step/@s : step (@s E1 E2 A'eA) (@s E1' E2 A'eA'') B'eB
       <- step E1 E1' (~</~> (=</~> AEA'' B'EB))
       <- promote AEA'' AeA''
       <- promote B'EB B'eB
       <- ~<-trans A'eA AeA'' A'eA''.

step/@sR : step (@s E1 E2' A'eA) (@s E1 E2'' A''eA) ~</e
	<- step E2' E2'' A''eA'
	<- ~<-trans A''eA' A'eA A''eA.

step/lam : step (@s (lam V _ _) E _) (V E) ~</e.

step/is_empty : step (@s is_empty empty _) empty ~</e.

step/getLeft : step (@s getLeft (obj L _) (~</prod A'A B'B)) L A'A.
step/getRight : step (@s getLeft (obj _ R) (~</prod A'A B'B)) R B'B.

step/switch-left  : step (@s (switch LF _) (@s left L LeP) (~</sum PeL' _)) (@s LF L LeL') ~</e
                <- ~<-trans LeP PeL' LeL'.

step/switch-right : step (@s (switch _ RF) (@s right R ReP) (~</sum _ PeR')) (@s RF R ReR') ~</e
                <- ~<-trans ReP PeR' ReR'.

%worlds () (step _ _ _).
%name step Step.


logic-less : tm A -> type.
%mode logic-less +A. %name logic-less LL.

logic-less/app-+ : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
               <- logic-less Ie
               <- tp-mode Bt pos
               <- tp-mode At neg.

% in this case, we simply don't care what happens.
logic-less/app++ : logic-less (@s (Fe : tm (At ~> Bt)) _ _) 
                <- tp-mode Bt pos
                <- tp-mode At pos.

logic-less/app : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
              <- logic-less Ie
              <- logic-less Fe.

logic-less/lam : logic-less (lam F _ _) 
              <- {I} logic-less I -> logic-less (F I).

logic-less/empty : logic-less empty.
logic-less/is_empty : logic-less is_empty.
logic-less/obj : logic-less (obj A B) <- logic-less B <- logic-less A.
logic-less/getLeft : logic-less getLeft.
logic-less/getRight : logic-less getRight.
logic-less/left : logic-less left.
logic-less/right : logic-less right.

%{ 
we need step and  "logic-less Be"
so that we know that Ae, despite being positively moded is actually 
free of logic variables by having progress.  
The existence of logic variables should hinder progress in a positively moded "thing"
so the existence of progress should imply no logic variables.

Since the existence of progress implies no logic variables, 
then the A that "findAll F" returns (where A is such that "step (F A) Success" and F returns positive and success contains no logic variables) 
must also contain no logic variables.
}%

resolving : step (Ae : tm At) Be _ 
         -> tp-mode At pos
         -> logic-less Be
         -> logic-less Ae
         -> type.

- : resolving step/is_empty _ _ (logic-less/app logic-less/is_empty logic-less/empty).
- : resolving step/getLeft Result_is_pos _ (logic-less/app++ (tp-mode/prod lub/e) Result_is_pos).
- : resolving step/getRight Result_is_pos _ (logic-less/app++ (tp-mode/prod lub/e) Result_is_pos).
- : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Result_is_pos _ (logic-less/app++ tp-mode/sum Result_is_pos).
- : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app-+ Input_is_pos Result_is_pos Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/left Ie)).
- : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app _ Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/left Ie)).

- : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Result_is_pos _ (logic-less/app++ tp-mode/sum Result_is_pos).
- : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app-+ Input_is_pos Result_is_pos Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/right Ie)).
- : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app _ Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/right Ie)).


%mode resolving +S +MAP +LLB -LLA.
%% Result_is_Pos should imply that the input to getLeft is pos.
