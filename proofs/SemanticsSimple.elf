%%%%%%%%%%%%%%%%%%%%%%%%
% what resolvedness is %
%%%%%%%%%%%%%%%%%%%%%%%%
mode : type.
pos : mode.
neg : mode.
%mode mode.
%freeze mode.
%name mode Gs.

<m : mode -> mode -> type. %infix right 5 <m.
%mode <m +A +B.
<m/e : A <m A.
<m/pn : pos <m neg.

ub : mode -> mode -> mode -> type.
ub/p : A <m C -> B <m C -> ub A B C.
%freeze ub. %name ub UB.

lub : mode -> mode -> mode -> type.
lub/e : lub A A A.
lub/pl : lub pos neg neg.
lub/pr : lub neg pos neg.
%mode lub +A +B -C.
%worlds () (lub _ _ _). 
%unique lub +A +B -1C.
%total {A B} (lub A B _).
%freeze lub. %name lub LUB.

glb : mode -> mode -> mode -> type.
glb/e : glb A A A.
glb/pl : glb pos neg pos.
glb/pr : glb neg pos pos.
%mode glb +A +B -C.
%worlds () (glb _ _ _). 
%unique glb +A +B -1C.
%total {A B} (glb A B _).
%freeze glb. %name glb GLB.

mode-sub-trans : A <m B -> B <m C -> A <m C -> type.
%mode mode-sub-trans +A +B -C.
mode-sub-trans/e :  mode-sub-trans <m/e A A.
mode-sub-trans/pn : mode-sub-trans <m/pn <m/e <m/pn.
%worlds () (mode-sub-trans _ _ _).
%unique mode-sub-trans +A +B -1C.
%total {A B} (mode-sub-trans A B _).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the types in the language %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tp : type.
tp-mode : tp -> mode -> type.
%mode tp-mode +A -B.

~> : tp -> tp -> tp. %infix right 6 ~>.
unit : tp.
sum : tp-mode Ta A -> tp-mode Tb B -> ub A B C -> tp.
%% should make this lub and not ub- infact, it could get removed all together 
prod : tp-mode Ta A -> tp-mode Tb B -> tp.  

tp-mode/~> : tp-mode (B ~> A) pos.
tp-mode/unit : tp-mode unit pos.
tp-mode/sum : tp-mode (sum _ _ (_ : ub _ _ C)) C.
tp-mode/prod : tp-mode (prod (_ : tp-mode _ A) (_ : tp-mode _ B)) C <- lub A B C.
%worlds () (tp-mode _ _).
%unique tp-mode +A -1B.
%total {} (tp-mode _ _).
%name tp-mode TM.
%name tp T t.

=< : tp -> tp -> type. %infix right 5 =<.
%mode =< +A +B.
=</e : A =< A.
=</~> : A' =< A -> B =< B' -> (A ~> B) =< (A' ~> B').
=</sum :  M <m M'
       -> A =< A'
       -> B =< B'
       -> (sum (_ : tp-mode A _) (_ : tp-mode B _) (_ : ub _ _ M)) =< (sum (_ : tp-mode A' _) (_ : tp-mode B' _) (_ : ub _ _ M')).
=</prod :  A =< A'
        -> B =< B'
        -> (prod (_ : tp-mode A _) (_ : tp-mode B _)) =< (prod (_ : tp-mode A' _) (_ : tp-mode B' _)).

=<-trans : A =< B -> B =< C -> A =< C -> type. 
=<-trans' : B =< C -> A =< B -> A =< C -> type. 

%mode =<-trans +A +B -C.
%mode =<-trans' +A +B -C.
- : =<-trans =</e A A.
- : =<-trans (=</~> AA' BB') (=</~> A'A'' B'B'') (=</~> AA'' BB'') <- =<-trans' AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</sum MM' AA' BB') (=</sum M'M'' A'A'' B'B'') (=</sum MM'' AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans (=</prod AA' BB') (=</prod A'A'' B'B'') (=</prod AA'' BB'') <- =<-trans AA' A'A'' AA'' <- =<-trans BB' B'B'' BB''.
- : =<-trans (=</~> AA' BB') =</e (=</~> AA' BB').
- : =<-trans (=</sum MM' AA' BB') =</e (=</sum MM' AA' BB').
- : =<-trans (=</prod AA' BB') =</e (=</prod AA' BB').

- : =<-trans' =</e A A.
- : =<-trans' (=</~> A'A'' B'B'') (=</~> AA' BB') (=</~> AA'' BB'') <- =<-trans A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</sum M'M'' A'A'' B'B'') (=</sum MM' AA' BB') (=</sum MM'' AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB'' <- mode-sub-trans MM' M'M'' MM''. 
- : =<-trans' (=</prod A'A'' B'B'') (=</prod AA' BB') (=</prod AA'' BB'') <- =<-trans' A'A'' AA' AA'' <- =<-trans' B'B'' BB' BB''.
- : =<-trans' (=</~> AA' BB') =</e (=</~> AA' BB').
- : =<-trans' (=</sum MM' AA' BB') =</e (=</sum MM' AA' BB').
- : =<-trans' (=</prod AA' BB') =</e (=</prod AA' BB').
%worlds () (=<-trans _ _ _) (=<-trans' _ _ _).
%unique (=<-trans +A +B -1C) (=<-trans' +A' +B' -1C').
%total (A B) (=<-trans A _ _) (=<-trans' B _ _).

=<implies<m : A =< A' -> tp-mode A M -> tp-mode A' M' -> M <m M' -> type.

%freeze =<implies<m.


% The definition of a tm (again)
% and other stuff with progress theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tm : tp -> type.

subRes : tp -> type.
subRes/dual : {B} tm B -> B =< B' -> subRes B'.

getSubRes : subRes B' -> {B} tm B -> B =< B' -> type.
%mode getSubRes +A -B -C -D.
getSubRes/get : getSubRes (subRes/dual B TmB BsB') B TmB BsB'.

used-as-neg : tm A -> tm B -> type.
used-neg : mode -> ({A'} A' =< A -> tm A' -> subRes B) -> type.


lam : {F : {A'} A' =< A -> tm A' -> subRes B } tp-mode A M -> used-neg M F -> tm (A ~> B).
empty : tm unit.
obj : tm A -> tm B -> tm (prod (A_m_Ma : tp-mode A _) (B_m_Mb : tp-mode B _)).
getLeft : tm (prod (A_m_Ma : tp-mode A M) (_ : tp-mode _ M)) -> tm A.
getRight : tm (prod (_ : tp-mode _ M) (B_m_Mb : tp-mode B _)) -> tm B.
left : tm (A ~> sum (_ : tp-mode A _) _ _).
right : tm (B ~> sum _ (_ : tp-mode B _) _).
% switch should be GLB not LUB, but right now just making them equal seems good enough.
switch : tm (A ~> C) 
      -> tm (B ~> C) 
      -> tm (sum (_ : tp-mode A MC) (_ : tp-mode B MC) (_ : ub _ _ MC) ~> C).
logic-var : tp-mode B neg -> tm B.
@s : tm (A ~> C) -> tm A' -> A' =< A -> tm C.
%name tm E.

used-as-neg' : tm A -> subRes B -> type.
used-as-neg'/eval : used-as-neg' A SubResB 
                 <- getSubRes SubResB _ TmB _ 
                 <- used-as-neg A TmB.

used-neg/pos : used-neg pos L.
used-neg/neg : ({A'}{s}{a} tp-mode A' neg -> used-as-neg' a (L A' s a)) -> used-neg neg L.

used-as-neg/e : tp-mode T neg -> used-as-neg (A : tm T) A.
used-as-neg/lam-inner : ({T'} {s}{e} used-as-neg' A (F T' s e)) 
                     -> used-as-neg A (lam F _ _).
used-as-neg/app-l : used-as-neg A E1 
                 -> used-as-neg A (@s E1 E2 _).
used-as-neg/app-r : tp-mode T1 neg 
                 -> tp-mode T1' neg 
                 -> used-as-neg A E2 
                 -> used-as-neg A (@s (E1 : tm (T1 ~> T2)) (E2 : tm T1') _).

used-as-neg/objL : used-as-neg A L 
		-> tp-mode To neg
                -> used-as-neg A (obj (L : tm To) R).

used-as-neg/objR : used-as-neg A R 
		-> tp-mode To neg
                -> used-as-neg A (obj L (R  : tm To)).

used-as-neg/product : used-as-neg (getLeft A) E 
                   -> used-as-neg (getRight A) E 
                   -> used-as-neg A E.

used-as-neg/sum-unused : used-as-neg A L1 
                       -> used-as-neg A L2 
                       -> used-as-neg A (switch L1 L2).


%worlds () (getSubRes _ _ _ _).
%total {A} (getSubRes A _ _ _).

step : tm A -> tm A' -> A' =< A -> type.
%mode step +A -B -C.

step/@s : step (@s E1 E2 A'eA) (@s E1' E2 A'eA'') B'eB
       <- step E1 E1' (=</~> AeA'' B'eB)
       <- =<-trans A'eA AeA'' A'eA''.

step/lam : step (@s (lam V _ _) (E : tm T) S) TmB B'eB <- getSubRes (V T S E) _ TmB B'eB.

step/getLeft : step (getLeft (obj L _)) L =</e.
step/getLeft-simp : step (getLeft A) (getLeft A') L'eL  <- step A A' (=</prod L'eL _).
step/getRight : step (getLeft (obj _ R)) R =</e.
step/getRight-simp : step (getRight A) (getRight A') R'eR  <- step A A' (=</prod _ R'eR).

step/switch-left  : step (@s (switch LF _) (@s left L LeP) (=</sum _ PeL' _)) (@s LF L LeL') =</e
                 <- =<-trans LeP PeL' LeL'.

step/switch-right : step (@s (switch _ RF) (@s right R ReP) (=</sum _ _ PeR')) (@s RF R ReR') =</e
                <- =<-trans ReP PeR' ReR'.

%worlds () (step _ _ _).
%name step Step.

logic-less : tm A -> type.
logic-less' : subRes A -> type.
logic-less'/get : logic-less' Sub <- getSubRes Sub _ TmB _ <- logic-less TmB.

%mode (logic-less +A) (logic-less' +A). 
%name logic-less LL.
%name logic-less' LL'.

logic-less/app-+ : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
               <- logic-less Ie
               <- tp-mode Bt pos
               <- tp-mode At neg.

% in this case, we simply don't care what happens.
logic-less/app++ : logic-less (@s (Fe : tm (At ~> Bt)) _ _) 
                <- tp-mode Bt pos
                <- tp-mode At pos.

logic-less/app : logic-less (@s (Fe : tm (At ~> Bt)) Ie _) 
              <- logic-less Ie
              <- logic-less Fe.

logic-less/lam : logic-less (lam F _ _) 
              <- {A}{s}{I} logic-less I -> logic-less' (F A s I).

logic-less/empty : logic-less empty.
logic-less/obj : logic-less (obj A B) <- logic-less B <- logic-less A.
logic-less/getLeft : logic-less A -> logic-less (getLeft A).
logic-less/getLeft-lazy : logic-less L -> logic-less (getLeft (obj L _ : tm (prod _ (_ : tp-mode _ pos)))).
logic-less/getRight : logic-less A -> logic-less (getRight A).
logic-less/getRight-lazy : logic-less R -> logic-less (getLeft (obj _ R: tm (prod (_ : tp-mode _ pos) _))).
logic-less/left : logic-less left.
logic-less/right : logic-less right.

%{ 
we need step and  "logic-less Be"
so that we know that Ae, despite being positively moded is actually 
free of logic variables by having progress.  
The existence of logic variables should hinder progress in a positively moded "thing"
so the existence of progress should imply no logic variables.

Since the existence of progress implies no logic variables, 
then the A that "findAll F" returns (where A is such that "step (F A) Success" and F returns positive and success contains no logic variables) 
must also contain no logic variables.

i think (@s (A: _/+ ~> _/+) (B : _/-) _) : _/- for this all to work.  which is an odd exception case, 
more accurately, "+ ~> +" is actually "- ~> -"
but corresponds to not actually being negative. that, or no right hand side steps. 
that InputIsPos is an argument to resolving why we need this stuff.
so we need a lemma that says (F I: A/+) => F:R/+ ~> O/+ => I:R/+.

}%

resolving : step (Ae : tm At) Be _ 
         -> tp-mode At pos
         -> logic-less Be
         -> logic-less Ae
         -> type.

0 : resolving (_ : step (@s E1 _ _) (@s E1 _ _) _) _ (logic-less/app++ Arg_Pos Arg_Neg) (logic-less/app++ Arg_Pos Arg_Neg).

2 : resolving step/getLeft Result_is_pos LogicLessLeft (logic-less/getLeft-lazy LogicLessLeft).
2' : resolving (step/getLeft-simp Step) Lpos (logic-less/getLeft LogicLessLeft) (logic-less/getLeft LogicLessLeft')
  <- resolving Step (tp-mode/prod lub/e) LogicLessLeft (LogicLessLeft' : logic-less L).

3 : resolving step/getRight Result_is_pos LogicLessLeft (logic-less/getRight-lazy LogicLessLeft).
3' : resolving (step/getRight-simp Step) Rpos (logic-less/getRight LogicLessRight) (logic-less/getRight LogicLessRight')
  <- resolving Step (tp-mode/prod lub/e) LogicLessRight LogicLessRight'.

4 : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Result_is_pos _ (logic-less/app++ tp-mode/sum Result_is_pos).
5 : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app-+ Input_is_pos Result_is_pos Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/left Ie)).
6 : resolving (step/switch-left _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app _ Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/left Ie)).

7 : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ pos) ~> _)) _ _) _  _)
              Result_is_pos _ (logic-less/app++ tp-mode/sum Result_is_pos).
8 : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app-+ Input_is_pos Result_is_pos Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/right Ie)).
9 : resolving (step/switch-right _ : step (@s (_ : tm (sum _ _ (_ : ub _ _ neg) ~> _)) _ _) _  _)
              Result_is_pos
              (logic-less/app _ Ie)
              (logic-less/app-+ tp-mode/sum Result_is_pos (logic-less/app logic-less/right Ie)).

10 : resolving (step/@s _ StepE1tE1') Result_is_Pos (logic-less/app LLFe LLIe) (logic-less/app LLFe' LLIe) 
  <- resolving StepE1tE1' tp-mode/~> LLFe LLFe'.

11 : resolving (step/@s _ _) Result_is_Pos (logic-less/app-+ Input_is_neg Result_is_Pos LLIe) (logic-less/app-+ Input_is_neg Result_is_Pos LLIe).

12 : resolving (step/lam (GetSubRes : getSubRes (V T S E) _ TmB B'eB) : step (@s (lam V _ _) E S) TmB B'eB) _ _ _.
%mode resolving +A +B +C -D.
%worlds () (resolving _ _ _ _).
