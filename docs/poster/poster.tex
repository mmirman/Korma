% --------------------------------------------------------------------------- %
% Poster for the ECCS 2011 Conference about Elementary Dynamic Networks.      %
% --------------------------------------------------------------------------- %
% Created with Brian Amberg's LaTeX Poster Template. Please refer for the     %
% attached README.md file for the details how to compile with `pdflatex`.     %
% --------------------------------------------------------------------------- %
% $LastChangedDate:: 2011-09-11 10:57:12 +0200 (V, 11 szept. 2011)          $ %
% $LastChangedRevision:: 128                                                $ %
% $LastChangedBy:: rlegendi                                                 $ %
% $Id:: poster.tex 128 2011-09-11 08:57:12Z rlegendi                        $ %
% --------------------------------------------------------------------------- %
\documentclass[a0paper,landscape]{baposter}

\usepackage{relsize}		% For \smaller
\usepackage{url}			% For \url
\usepackage{epstopdf}	% Included EPS files automatically converted to PDF to include with pdflatex
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[numbers]{natbib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
  \theoremstyle{definition}
  \newtheorem*{example*}{Example}
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}
\theoremstyle{plain}
\newtheorem{thm}{Theorem}
  \theoremstyle{definition}
  \newtheorem{defn}[thm]{Definition}
  \theoremstyle{plain}
  \newtheorem{lem}[thm]{Lemma}
  \theoremstyle{plain}
  \newtheorem{prop}[thm]{Proposition}
  \theoremstyle{plain}
  \newtheorem{cor}[thm]{Corollary}


%%% Global Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\graphicspath{{pix/}}	% Root directory of the pictures 
\tracingstats=2			% Enabled LaTeX logging with conditionals

%%% Color Definitions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{bordercol}{RGB}{40,40,40}
\definecolor{headercol1}{RGB}{186,215,230}
\definecolor{headercol2}{RGB}{80,80,80}
\definecolor{headerfontcol}{RGB}{0,0,0}
\definecolor{boxcolor}{RGB}{186,215,230}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utility functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Save space in lists. Use this after the opening of the list %%%%%%%%%%%%%%%%
\newcommand{\compresslist}{
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Document Start %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\typeout{Poster rendering started}

%%% Setting Background Image %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\background{
	\begin{tikzpicture}[remember picture,overlay]%
	\draw (current page.north west)+(-2em,2em) node[anchor=north west]
	{\includegraphics[height=1.1\textheight]{background}};
	\end{tikzpicture}
}

%%% General Poster Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Eye Catcher, Title, Authors and University Images %%%%%%%%%%%%%%%%%%%%%%
\begin{poster}{
	grid=false,
	% Option is left on true though the eyecatcher is not used. The reason is
	% that we have a bit nicer looking title and author formatting in the headercol
	% this way
	%eyecatcher=false, 
	borderColor=bordercol,
	headerColorOne=headercol1,
	headerColorTwo=headercol2,
	headerFontColor=headerfontcol,
	% Only simple background color used, no shading, so boxColorTwo isn't necessary
	boxColorOne=boxcolor,
	headershape=roundedright,
	headerfont=\Large\sf\bf,
	textborder=rectangle,
	background=user,
	headerborder=open,
        boxshade=plain
}
%%% Eye Cacther %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
	Eye Catcher, empty if option eyecatcher=false - unused
}
%%% Title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\sf\bf
	Modes For a Non Strict Functional Logical Language
}
%%% Authors %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
	\vspace{1em} Matthew Mirman (mmirman@andrew.cmu.edu)\\ 
                     Advisor: Frank Pfenning (fp@cs.cmu.edu)\\
}
%%% Logo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
% The logos are compressed a bit into a simple box to make them smaller on the result
% (Wasn't able to find any bigger of them.)
\setlength\fboxsep{0pt}
\setlength\fboxrule{0.5pt}
	\fbox{
		\begin{minipage}{14em}
%			\includegraphics[width=10em,height=4em]{colbud_logo}
%			\includegraphics[width=4em,height=4em]{elte_logo} \\
%			\includegraphics[width=10em,height=4em]{dynanets_logo}
%			\includegraphics[width=4em,height=4em]{aitia_logo}
		\end{minipage}
	}
}

\headerbox{Abstract}{name=abstract,column=0,row=0}{
Functional logic programming is a paradigm that introduces proof search
as a first class construct into the functional setting. In consolidating
logic and functional semantics, a complete logic query primitive is
desirable. A type and mode system for safetly interacting with this primitve
is provided.  Proofs of the utility of the system for preventing undefined
behavior are provided and formalized in the proof checker Twelf. 
It is also shown that properties of the system correspond with properties of
a strictness analysis system.
}

\headerbox{Functional Logic Programming}{name=flp,column=0,below=abstract}{
\smaller
To illustrate a case where functional logic programming\citep{FLP}
would be convenient, consider the following Haskell code:
\begin{lyxcode}

step~(App~(Lam~f)~e2)~res~\textbf{=}~

~~~~res~\textbf{==}~f~e2

step~(App~e1~e2)~(App~e1'~e2')~\textbf{=}~

~~~~(e1'~\textbf{==~}e1~\textbf{\emph{`and`}}~step~e2~e2')~

\textbf{\emph{~`or`}}~(e2'~\textbf{==~}e2~\textbf{\emph{`and`}}~step~e1~e1')

\textbf{\emph{`or`}}~(e2'~\textbf{==~}e2~\textbf{\emph{`and`}}~step~e1~e1')
\end{lyxcode}
A functional attempt at converting this function to one 
which lists all possible terms might use this predicate as a filter.
\begin{lyxcode} 
reducts~term~=~filter~(step~term)~listAllTerms
\end{lyxcode}
In a functional logic language, search is built in:
\begin{lyxcode}
reducts~term~=~\textbf{\emph{findAll}}\emph{~}red~\textbf{\emph{in}}~step~term~red
\end{lyxcode}
}

\headerbox{Problem}{name=problem,column=0, below=flp}{
In the Needed Narrowing\citep{Sergio1994} evaluation strategy, it
is possible to determine the truth of a proposition applied to argument
without entirely entirely figuring out the argument.  
\begin{lyxcode}
\smaller
list~=~\emph{findAll}~\$~\textbackslash{}a~->~\emph{free}~\$~\textbackslash{}z~->~case~z~of

~~~~A~->~left~a~==~A

~~~~B~->~(right~a,left~a)~==~({[}A{]},A)~
\end{lyxcode}
Given the needed narrowing evaluation strategy, list would contain
two values, {}``( A , ? )'' and {}``(A,{[}A{]})''. We can thus
infer that the type of list is $[(A+B)\times[A+B]]$. Mode analysis\citep{Pfenning1996}
might be used as a means of ensuring results from \textbf{findAll}
are ground. 

}

\headerbox{Language}{name=types,span=2,column=1, row=0}{

\begin{description}
\item [{Types}] $t\;::=t\rightarrow t\;|\; t\twoheadrightarrow t\;|\;1\;|\;\mbox{answer}\;|\; t\times t\;|\; t+_{m}t$\end{description}
\begin{defn}
The immediate mode of a type is $t\sim m$
\end{defn}
\begin{defn}
$T\leq T'$ simply means that $T$and $T'$ have the same structure
but different modes. At each sum, $m\leq m'$.
\end{defn}


\begin{defn}
The typing relation is as follows:
\end{defn}
\smaller
\begin{tabular}{cc}
$\mbox{(OF-RIGHT)}\frac{\Gamma\vdash a:v_{2}\;\;\; v_{1}+_{m}v_{2}\approx m}{\Gamma\vdash\mbox{inr}\; a\;:v_{1}+_{m}v_{2}}$ & $\mbox{(OF-ASSUM)}\frac{}{\Gamma,x:T\vdash x:T}$\tabularnewline
$\mbox{(OF-Left)}\frac{\Gamma\vdash a:v_{1}\;\;\; v_{1}+_{m}v_{2}\approx m}{\Gamma\vdash\mbox{inl}\; a\;:v_{1}+_{m}v_{2}}$ & $\mbox{(OF-SUBSUMP)}\frac{\Gamma\vdash e:T\;\; T\leq T'\;\; T'\approx m}{\Gamma\vdash e:T'}$\tabularnewline
$\mbox{(OF-OBJ)}\frac{\Gamma\vdash e_{1}:v_{1}\;\; v_{1}\sim m\;\;\;\Gamma\vdash e_{2}:v_{2}\;\; v_{2}\sim m}{\Gamma\vdash(e_{1},e_{2}):\; v_{1}\times v_{2}}$ & $\mbox{(OF-LAM)}\frac{\Gamma,x:T_{1}\vdash e:T_{2}\;\; T_{1}\approx m_{1}\;\;\; T_{2}\approx m_{2}\;\; x\notin V[\Gamma]}{\Gamma\vdash(\lambda x:T_{1}.e):T_{1}\rightarrow T_{2}}$\tabularnewline
$\mbox{(OF-UNIT)}\frac{}{\Gamma\vdash\mbox{unit}:1}$ & $\mbox{(OF-APP)}\frac{\Gamma\vdash e_{1}:T_{1}\rightarrow T_{2}\;\Gamma\vdash e_{2}:T_{1}}{\Gamma\vdash e_{1}e_{2}:T_{2}}$\tabularnewline
$\mbox{(OF-CASE-OF)}\frac{\Gamma\vdash l:v_{1}\rightarrow v_{3}\;\;\;\Gamma\vdash r:v_{2}\rightarrow v_{3}\;\;\Gamma\vdash e:v_{1}+_{m}v_{2}\;\; v_{1}\approx m\;\;\; v_{2}\approx m}{\Gamma\vdash\mbox{case}\; e\;\mbox{of}\; l\; r:\; v_{3}}$ & $\mbox{(OF-LOGIC-VAR)}\frac{T\approx\ominus}{\Gamma\vdash\mbox{unresolved}:T}$\tabularnewline
& $\mbox{(OF-PROJ)}\frac{\Gamma\vdash a:v_{1}\times v_{2}\;\;\; v_{1}\times v_{2}\approx m}{\Gamma\vdash\pi_{i}a:v_{2}}$\tabularnewline
\end{tabular}

\begin{defn} The interesting cases for the big step semantics are shown below. \end{defn}
\begin{tabular}{cc}
$\mbox{(E-FINDALL-SUCC) }\frac{\vdash V:T\;\;(E\; V)\Rightarrow\mbox{success}}{\mbox{findAll}_{T}\; E\Rightarrow(inl\; V)}$ & $\mbox{(E-FREE-FAIL) }\frac{\forall V:T\;\;\; E\; V\Rightarrow fail}{\mbox{free}_{T}\; E\Rightarrow fail}$\tabularnewline
$\mbox{(E-FINDALL-FAIL) }\frac{\forall V:T\;\;(E\; V)\Rightarrow\mbox{fail}}{\mbox{findAll}_{T}\; E\Rightarrow(\mbox{inr}\;\mbox{unit})}$ & $\mbox{(E-FREE-SUCC) }\frac{\vdash V:T\;\;\; E\; V\Rightarrow\mbox{success}}{\mbox{free}_{T}\; E\Rightarrow\mbox{success}}$\tabularnewline
\end{tabular}
}

\headerbox{Mode Checking}{name=modecheck,span=2,column=1,below=types}{

Mode checking is performed in a second pass on the abstract syntax tree.  Here we check that
every lambda expression which should use its argument in fact does use its argument.

\begin{defn}
$usedCorrectly_{m}(X,E)$ is defined according to the following rules,
on type annotated terms $E$ and $X$ and mode $m$.
\end{defn}
\smaller % Make the whole text smaller
\begin{tabular}{cc}
$\mbox{(UC/OBJ-L)}\frac{usedCorrectly_{m}(X,E_{1})\;\;(E_{1},E_{2})/\ominus}{usedCorrect_{m}(X,(E_{1},E_{2}))}$ & $\mbox{(UC/VAR)}\frac{}{usedCorrectly_{\ominus}(X,X)}$\tabularnewline
$\mbox{(UC/SUM-ARG)}\frac{usedCorrectly_{m}(X,E)}{usedCorrect_{m}(X,\mbox{case}\; E\;\mbox{of}\; E_{1}\; E_{2})}$ & $\mbox{(UC/LAM)}\frac{usedCorrectly_{m}(X,[y/x]E)\;\;\;\;\mbox{x is new}}{usedCorrect_{m}(X,\lambda y:t.E)}$\tabularnewline
$\mbox{(UC/SUM-C)}\frac{usedCorrectly_{m}(X,E_{1})\;\; usedCorrectly_{m}(X,E_{2})}{usedCorrect_{m}(X,\mbox{case}\; E\;\mbox{of}\; E_{1}\; E_{2})}$ & $\mbox{(UC/APP-L)}\frac{usedCorrectly_{m}(X,E_{1})}{usedCorrectly_{m}(X,E_{1}E_{2})}$\tabularnewline
$\mbox{(UC/OBJ)}\frac{usedCorrectly_{m}(X,E_{1})\;\; usedCorrectly_{m}(X,E_{2})}{usedCorrect_{m}(X,(E_{1},E_{2}))}$ & $\mbox{(UC/APP-R)}\frac{usedCorrectly_{\ominus}(X,E_{2})\;\; E_{1}::\; t_{1}\rightarrow t_{2}\;\; t_{1}\sim\ominus}{usedCorrect_{m}(X,E_{1}E_{2})}$\tabularnewline
\end{tabular}

}

\headerbox{Theorems}{name=theorems,span=2,column=1, below=modecheck}{

\begin{thm}
Preservation: $E\Rightarrow E'$ and $\vdash E:T$ then $\vdash E':T'$
and $T'\leq T$.
\end{thm}

\begin{lem}
If $E\implies_{\alpha}E'$ and $logicFree(E)$ then $logicFree(E')$\end{lem}
\begin{thm}
$\mbox{usedCorrectly}_{m}(X,E)$ and $logicFree(E)$ implies $ $$logicFree(X)$.
\end{thm}

\begin{thm}
Subterm-Resolving: $\Gamma\vdash X:T_{x}$ and $\mbox{usedCorrectly}_{\oplus}(X,E)$
and $\Gamma\vdash E:T_{E}$ and $T_{E}\approx\oplus$ and $E\Rightarrow_{*}V$
where $\Gamma\vdash V:T_{V}$,  and $\mbox{logicFree(V)}$ then $ $$logicFree(X)$
\end{thm}

\begin{thm}
Progress: $E:T$ and $T\approx\oplus$ implies either $E$ is a value
or $E\Rightarrow_{S}E'$ for some $E'$. Furthermore, if $E$ does
not contain logic variables, then $E'$ will also contain no logic
variables.
\end{thm}
}

\headerbox{Strictness}
{name=strict,span=1,column=3}{
\smaller % Make the whole text smaller
\begin{defn}
A function E is grounding if when $E\; V\implies C$ and $C$ has
no logic variables, and both $C$ and $V$ are values, then $V$ has
no logic variables.
\end{defn}

\begin{defn}
A function $E$ is strict if $E\circ hnf\equiv E$, where $hnf$ is
the function that evaluates it's arguments to head normal form. \end{defn}
\begin{prop}
$E$ is strict iff E is grounding.\end{prop}
\begin{cor}
A combinator$E$ is strict if $\vdash E:I\rightarrow O$ and $I\sim\ominus$
and $O\sim\oplus$. 
\end{cor}
Because mode checking and strictness checking are equivalent, mode
checking algorithms can be used for strictness analysis. The predicate
$usedCorrectly$ coresponds the notion of a strict use of it's argument.
}


\headerbox{Conclusions}
{name=conclusions,span=1,column=3, below=strict}{
In this thesis, we discussed a lazy functional logic language similar
to Curry\citep{Curry} and proved its runtime safety. We supplied
a mode system and a way to separate nondeterminism from input and
output. However, the mode system is not always entirely expressive
enough. It is also still necessary to show the safety of extensions
of polymorphism and recursion to the current mode algorithm. Finally,
a full implementation of the language has yet to be completed.

}


\headerbox{}
{name=references,span=1,column=3,below=conclusions}{
\smaller % Make the whole text smaller
\vspace{-0.4em} % Save some space at the beginning

\bibliographystyle{amsplain}
\bibliography{MyBib.bib}

}

\end{poster}
\end{document}
