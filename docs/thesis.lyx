#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
 \usepackage{babel}

\newcommand{\judges}{ \; \; \; \Gamma \vdash}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 2
\use_esint 1
\cite_engine natbib_numerical
\use_bibtopic false
\paperorientation portrait
\leftmargin 1.5in
\rightmargin 1.5in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Modes for Non Strict Functional Logic Languages
\end_layout

\begin_layout Author
Matthew Mirman (mmirman@andrew.cmu.edu)
\begin_inset Newline newline
\end_inset

Advisor: Frank Pfenning (fp@cs.cmu.edu)
\end_layout

\begin_layout Abstract
Functional logic programming is a paradigm that introduces proof search
 as a first class construct into the functional setting.
 In consolidating logic and functional semantics, a complete logic query
 primitive is desirable.
 In the reasonable and efficient evaluation strategy, it is possible to
 determine the correctness of a statement without entirely determining the
 proof.
 This would allow searches to leave their intended scope.
 Given the small step operational semantics for a practical lazy functional
 logic language, I approximate them with natural semantics for a lambda
 calculus with lazy logic primitives for which I supply a type and mode
 system.
 Types are annotated with modes denoting their intended groundedness attributes.
 Furthermore, given that the analysis is to be performed on functional logic
 code, the type system allows annotation of higher order function types
 with modes.
 Modes are observed as forming a natural ordering, and thus type and mode
 checking supports limited subtyping.
 I prove in Twelf the soundness of the annotations produced from type checking,
 and type preservation.
 A proof of progress depending on the existence of the resolving property
 of positively moded terms is discussed.
 It is also noted that positively moded corresponds with the notion of strict,
 and that the mode analysis could be considered a specialized strictness
 analysis.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Logic programming is a powerful model for describing complex queries, and
 encourages programmers to very often write less verbose code.
 Pure logic programming involves listing values satisfying predicates over
 simple data types.
 However, logic programming alone is not always the correct tool of choice.
 While logic programming is very good for describing a single static data
 input and output, it alone is not adept at describing dynamic interactions.
 Because logic programming describes so much computation in so little code
 by way of automation, the operational meaning of code is often obfuscated
 if not entirely unspecified.
 In cases where the action of the computer is to be specified, functional
 code is ideal.
 While it is simple to write a language where functional code can call logic
 code written separately, mixing the two to allow functional code to be
 accessed within logic code would logic.
\end_layout

\begin_layout Standard
In this thesis, I provide static analysis for a lambda calculus with additional
 logic primitives, in order to inform practical functional logic languages.
 The language I analyze here is an extension of the lambda calculus which
 includes the logic primitives 
\series bold
free, findAll
\series default
, and
\series bold
 caseof
\series default
.
 
\series bold
free
\series default
 is a function which initializes a variable as a free parameter in it's
 scope.
 
\series bold
findAll
\series default
 searches for any or all instances of a variable which satisfy a predicate.
 
\series bold
caseof
\series default
 non-deterministically branches when given a logic variable as an argument.
 
\end_layout

\begin_layout Standard
Nondeterministically branching for every free variable at every switch statement
 could very easily result in an unnecessarily slow programs; thus a non
 strict evaluation strategy is desired.
 The 
\emph on
Needed Narrowing
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "Sergio1994"

\end_inset

 evaluation strategy optimal in this respect.
 It iterates by lazily reducing a term, and only initializing logic variables
 if they are used as the argument to a 
\series bold
caseof
\series default
 statement whose results are required to continue execution.
 Beyond simply being more efficient, needed narrowing is complete 
\begin_inset CommandInset citation
LatexCommand citep
key "Sergio1994"

\end_inset

 in the same sense as non strict program evaluation.
 A reduction strategy for lambda calculus is complete if every expression
 for which there exists a reduction resulting in a value reduces under that
 strategy to a value.
 Similarly, a reduction strategy for lambda calculus is complete if it has
 the previous property, and also has the property that for all values such
 that predicate passed to 
\series bold
findAll
\series default
 has a reduction to success when applied to that value, then that value
 will appear somewhere in the result of the 
\series bold
findAll
\series default
.
\end_layout

\begin_layout Example*
To illustrate a case where functional logic programming would be convenient,
 consider the following Haskell code:
\end_layout

\begin_layout LyX-Code
step (App (Lam f) e2) res 
\series bold
=
\series default
 
\end_layout

\begin_layout LyX-Code
    res 
\series bold
==
\series default
 f e2
\end_layout

\begin_layout LyX-Code
step (App e1 e2) (App e1' e2') 
\series bold
=
\series default
 
\end_layout

\begin_layout LyX-Code
    (e1' 
\series bold
== 
\series default
e1 
\series bold
\emph on
`and`
\series default
\emph default
 step e2 e2') 
\end_layout

\begin_layout LyX-Code

\series bold
\emph on
 `or`
\series default
\emph default
 (e2' 
\series bold
== 
\series default
e2 
\series bold
\emph on
`and`
\series default
\emph default
 step e1 e1')
\end_layout

\begin_layout Standard
This code defines a predicate that ensures its second lambda term is a single
 step nondeterministic reduction of the first.
 It is simpler than the code that performs a single step nondeterministic
 reduction.
 Just given this predicate, we cannot easily construct a function that lists
 all possible single step reductions of a term.
 A naive attempt might list all possible terms and use this predicate as
 a filter.
\end_layout

\begin_layout LyX-Code
reductions term = filter (step term) listAllTerms
\end_layout

\begin_layout Standard
In a functional logic language, a more efficient function to output the
 same set of items can be defined far more easily:
\end_layout

\begin_layout LyX-Code
reductions term = 
\series bold
\emph on
findAll
\series default
 
\emph default
red 
\series bold
\emph on
in
\series default
\emph default
 step term red
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
While functional logic programming has become more present with the formulation
 of small step semantics, it appears as though less attention has been paid
 to the static analysis and verification of such languages.
 There do exist non strict functional logic programming language implementations
\begin_inset CommandInset citation
LatexCommand cite
key "FLP"

\end_inset

, but no practical language appears to statically verify runtime safety
 entirely.
 If the language is intended to be efficiently compiled to safe code, statically
 ensuring safety is essential.
 Furthermore, functional logic programming presents a great shift from imperativ
e or functional paradigms that programmers often learn first.
 It is thus necessary for the compiler to provide as much feedback as possible
 to inform the programmer of the correct use of the language, without hindering
 the readability of code.
 As reasoning about the time complexity of logic code is undesirable and
 difficult in the intended setting, the non strict and complete evaluation
 strategy known as needed narrowing is used.
 I note that in conjunction with a non strict evaluation strategy, it is
 possible for 
\series bold
findAll
\series default
 to return unground logic variables, despite being the only block against
 nondeterminism.
 Mode analysis
\begin_inset CommandInset citation
LatexCommand citep
key "Pfenning1996"

\end_inset

 might be used as a means of ensuring results from 
\series bold
findAll
\series default
 are ground.
 As logic code can be considered a non-deterministic search, the primitive
 
\series bold
findAll
\series default
 is highly concurrent.
 However, the unconstrained use of free variables throughout code could
 easily result in space leaks and unintentional non-determinism.
 I present a type level system for constraining the scope of non determinism
 in plausible programs
\end_layout

\begin_layout Standard
In a non strict evaluation strategy, logic variables are never initialized
 until they are needed to make progress.
 It is important that if there are values that when input to a predicate
 result in success, that the primitive 
\series bold
findAll
\series default
 will output those values rather than diverging before outputting them.
 This completeness property of findAll can be ensured by a breadth first
 search of possible variable initializations and evaluations.
 While both depth first and breadth first searches are possible in Curry
 and Prolog in the absence of a 
\series bold
findAll
\series default
 primitive, I show that the introduction of 
\series bold
findAll
\series default
 as a language primitive make controlling non-determinism in the I/O monad
 possible.
 The introduction of 
\series bold
findAll
\series default
 as a complete primitive in the presence of non strict semantics makes mode
 checking a necessity.
\end_layout

\begin_layout Example*
Consider the following hypothetical code
\end_layout

\begin_layout LyX-Code
list = 
\emph on
findAll
\emph default
 $ 
\backslash
a -> 
\emph on
free
\emph default
 $ 
\backslash
z -> case z of
\end_layout

\begin_layout LyX-Code
    A -> left a == A
\end_layout

\begin_layout LyX-Code
    B -> (right a,left a) == ([A],A) 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Given the needed narrowing evaluation strategy, list would contain two values,
 
\begin_inset Quotes eld
\end_inset

( A , ? )
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

(A,[A])
\begin_inset Quotes erd
\end_inset

.
 We can thus infer that the type of list is 
\begin_inset Formula $[(A+B)\times[A+B]]$
\end_inset

 .
 However, if we were to ask for 
\begin_inset Quotes eld
\end_inset

right (head list)
\begin_inset Quotes erd
\end_inset

, we would have encountered a logic variable.
 We say that this predicate is not grounding.
 The effects from non resolving code can be non local and non-intuitive
 for a novice logic programmer, and thus preventing findAll from accepting
 non resolving functions is necessary.
 
\end_layout

\begin_layout Section
Language Definition
\end_layout

\begin_layout Standard
It is first necessary to provide a language as a target for the analysis.
 To simplify recursive types, and polymorphism are omitted, although it
 is likely that they will not pose significant complications in the future
 if restricted in the usual fashions.
 For purposes of the proof, the term 
\series bold
unresolved
\series default
 is also included, which is used as a logic variable which can have any
 negatively moded type.
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Standard
The syntax for the language is defined as follows.
 
\end_layout

\begin_layout Description
Modes 
\begin_inset Formula $m\;::=\oplus\;|\;\ominus$
\end_inset


\end_layout

\begin_layout Description
Types 
\begin_inset Formula $t\;::=t\rightarrow t\;|\; t\twoheadrightarrow t\;|\;1\;|\;\mbox{answer}\;|\; t\times t\;|\; t+_{m}t$
\end_inset


\end_layout

\begin_layout Description
Terms 
\begin_inset Formula $e\;::=x\;|\;\lambda x:t.e\;|\;\lambda v.e\;|\;(e\; e)\;|$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{findAll}_{t}\;|\;\mbox{free}_{t}\;|\;\mbox{success}\;|\;\mbox{fail}\;|\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
(e,e)\;|\;\pi_{1}\;|\;\pi_{2}\;|\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{inl}\;|\;\mbox{inr}\;|\;\mbox{case\;}e\;\mbox{of}\;(e_{1},e_{2})|\;\mbox{unit}\;|\;\mbox{unresolved}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Subsection
Semantics
\end_layout

\begin_layout Standard
Language semantics are a crucial property to specify before meaningful analysis
 can take place.
 logic languages when given naive semantics can be extraordinarily inefficient.
 Needed narrowing is an evaluation strategy where variables are only instantiate
d when continuing the lazy evaluation of a predicate requires their instantiatio
n, such as at a branching construct.
 The small step needed narrowing semantics 
\begin_inset CommandInset citation
LatexCommand citep
key "Albert02adeterministic"

\end_inset

 as shown below have been known in practice to give good results.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\align center
Small step operational semantics 
\begin_inset CommandInset citation
LatexCommand citep
key "Albert02adeterministic"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Control
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stack
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-VARCONS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto t]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto t]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-VAREXP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto e]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e is not constructor rooted
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto t]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e\neq x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-VAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v$
\end_inset

 is constructor rooted or a 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto v]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable with 
\begin_inset Formula $\Gamma[y]=y$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-LAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\lambda x:t.e)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e':S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset

 is fresh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[y\mapsto e']$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[x\mapsto y]e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-APP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}\; e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-CASE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}\;\; LF\;\; RF\;\; e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}LF\; RF:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-CASE-L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{inl }e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}LF\; RF:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $LF\; e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-CASE-R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{inr }e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}LF\; RF:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RF\; e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-GUESS-L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto x]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}LF\; RF:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset

 is fresh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto\mbox{inl}\; y,\; y\mapsto y]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $LF\; y$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-GUESS-R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto x]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{caseof}LF\; RF:S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset

 is fresh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[x\mapsto\mbox{inr}\; y,\; y\mapsto y]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RF\; y$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ST-FREE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mbox{free}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\lambda x.e):S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset

 is fresh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma[y\mapsto y]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[x\mapsto y]e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The semantics used in our analysis is a reduction semantics which approximates
 the small step semantics above.
 
\end_layout

\begin_layout Definition
\begin_inset Formula $E\Rightarrow E'$
\end_inset

 is the lazy big step reduction defined as follows.
 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-LAM)}(\lambda x:t.F)\Rightarrow(\lambda x:t.F)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-OBJ)}(A,B)\Rightarrow(A,B)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-UNIT)}\mbox{unit}\Rightarrow\mbox{unit}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-SUCCESS)}\mbox{success}\Rightarrow\mbox{success}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-FAIL)}\mbox{fail}\Rightarrow\mbox{fail}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-INL)}\mathbf{inl}\; A\Rightarrow\mathbf{inl}\; A\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-ID-INR)}\mathbf{inr}\; A\Rightarrow\mathbf{inr}\; A\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-APP-LAM)}\frac{E_{1}\Rightarrow(\lambda x:t.F)\;\;\;\;[x\mapsto E_{2}]F\Rightarrow V}{E_{1}\;\; E_{2}\Rightarrow V}\mbox{provided x is free for e_{2} in e_{1}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\mbox{(E-GET) } & \frac{E\Rightarrow(E_{1},E_{2})\;\; E_{i}\Rightarrow V}{\pi_{i}E\Rightarrow V}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-SWITCH-LEFT) \frac{E\Rightarrow\mathbf{inl}\; L\;\;\; LF\; L\Rightarrow V}{\mbox{case}\; E\;\mbox{of}\;(LF,RF)\Rightarrow V}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-SWITCH-RIGHT) }\frac{E\Rightarrow\mathbf{inr}\; R\;\;\; RF\; R\Rightarrow V}{\mbox{case}\; E\;\mbox{of}\;(LF,RF)\Rightarrow V}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-FINDALL-SUCC) }\frac{\vdash V:T\;\;(E\; V)\Rightarrow\mbox{success}}{\mbox{findAll}_{T}\; E\Rightarrow(inl\; V)}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-FINDALL FAIL) }\frac{\forall V:T\;\;(E\; V)\Rightarrow\mbox{fail}}{\mbox{findAll}_{T}\; E\Rightarrow(\mbox{inr}\;\mbox{unit})}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-FREE-SUCC) }\frac{\vdash V:T\;\;\; E\; V\Rightarrow\mbox{success}}{\mbox{free}_{T}\; E\Rightarrow\mbox{success}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(E-FREE-SUCC) }\frac{\vdash V:T\;\;\; E\; V\Rightarrow fail}{\mbox{free}_{T}\; E\Rightarrow fail}\]

\end_inset


\end_layout

\begin_layout Standard
Note that in these rules we need no context, since 
\begin_inset Formula $V$
\end_inset

 should not contain free variables.
 Importantly, the big step semantics also have the useful property that
 the result of a reduction is always in weak head normal form.
 
\end_layout

\begin_layout Subsection
Type and Mode Checking
\end_layout

\begin_layout Standard
Modes are a system for characterizing what arguments are input and outputs
 for a predicate.
 We say that a value is ground or resolved if all of its constituents are
 known.
 We can say that an argument is intended to be an output to a predicate
 if, upon satisfying that predicate, it must be ground.
 An argument is an input to a predicate if it will be ground on every instantiat
ion of the rule.
 
\end_layout

\begin_layout Standard
In order to discuss the type checker, it is necessary to first describe
 the relationship between types and modes.
 The mode 
\begin_inset Formula $\oplus$
\end_inset

 describes values which do not need to become ground, and the mode 
\begin_inset Formula $\ominus$
\end_inset

 describes values which must become ground.
 We can use a value which does not need to become ground anywhere we know
 we will ground the value, but we should not use a value which must become
 ground anywhere we do not know we will ground it (some programs which violate
 this rule will be correct, but this rule makes life easier).
 Thus, 
\begin_inset Formula $\oplus\leq\ominus$
\end_inset

.
 As usual, 
\begin_inset Formula $\sqcup$
\end_inset

 will describe the least upper bound.
 
\end_layout

\begin_layout Standard
We also need to define what it means for a type to specify a mode.
 
\end_layout

\begin_layout Definition
The immediate mode of a type 
\begin_inset Formula $t\sim m$
\end_inset

 is defined as follows.
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE/UNIT)}\;\emptyset\sim\oplus\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE/SUM)}\; t_{1}+_{m}t_{2}\sim m\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE/PROD)}\;\frac{t_{1}\sim m_{1}\;\; t_{2}\sim m_{2}}{t_{1}\times t_{2}\sim m_{1}\sqcup m_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE/ARROW)\;}t_{1}\rightarrow t_{2}\sim\oplus\]

\end_inset


\end_layout

\begin_layout Standard
Not all types are necessarily well-moded.
 In order for a type to be well-moded, sums must have a mode that is an
 upper bound of the modes of it's constituent types.
\end_layout

\begin_layout Definition
The safe mode of a type 
\begin_inset Formula $t\approx m$
\end_inset

 is inductively defined as follows 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE-SAFE/UNIT)}\;\emptyset\approx\oplus\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE-SAFE/SUM)}\;\frac{t_{1}\approx m_{1}\;\; t_{2}\approx m_{2}\;\; m_{1}\leq m\;\; m_{2}\leq m}{t_{1}+_{m}t_{2}\approx m}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE-SAFE/PROD)}\;\frac{t_{1}\approx m_{1}\;\; t_{2}\approx m_{2}}{t_{1}\times t_{2}\approx m_{1}\sqcup m_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(TP-MODE-SAFE/ARROW)\;}\frac{t_{1}\approx m_{1}\;\; t_{2}\approx m_{2}}{t_{1}\rightarrow t_{2}\approx\oplus}\]

\end_inset


\end_layout

\begin_layout Lemma
All types have a unique immediate mode.
\end_layout

\begin_layout Proof
The proof is trivial by induction on the structure of a type.
 
\end_layout

\begin_layout Lemma
If a type has a safe mode, it has the same immediate mode.
\end_layout

\begin_layout Proof
The proof is by induction on the structure of the predicate 
\begin_inset Formula $t\approx m$
\end_inset

.
 The intuition here is that 
\begin_inset Formula $t\sim m$
\end_inset

 produces 
\begin_inset Formula $m$
\end_inset

 in the same way that 
\begin_inset Formula $t\approx m$
\end_inset

 produces 
\begin_inset Formula $m$
\end_inset

, but 
\begin_inset Formula $t\approx m$
\end_inset

 performs extra checks.
 
\end_layout

\begin_layout Standard
Before we can discuss type checking, we need to explain the subtype relation.
 
\end_layout

\begin_layout Definition
\begin_inset Formula $T\leq T'$
\end_inset

 simply means that 
\begin_inset Formula $T$
\end_inset

and 
\begin_inset Formula $T'$
\end_inset

 have the same structure but different modes.
 At each sum, 
\begin_inset Formula $m\leq m'$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Formula \[
1\leq1\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\frac{T_{1}\leq T'_{1}\;\;\; T_{2}\leq T'_{2}}{T_{1}\times T_{2}\leq T'_{1}\times T'_{2}}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\frac{T_{1}\leq T'_{1}\;\;\; T_{2}\leq T'_{2}\;\;\; m\leq m'}{T_{1}+_{m}T_{2}\leq T'_{1}+_{m'}T_{2}'}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\frac{T'_{1}\leq T{}_{1}\;\;\; T_{2}\leq T'_{2}}{T_{1}\rightarrow T_{2}\leq T'_{1}\rightarrow T_{2}'}\]

\end_inset


\end_layout

\begin_layout Standard
The following lemmas are relied on heavily thought the proof of preservation
 and progress, and have been entirely formalized in Twelf in the TypeTheorems
 file.
\end_layout

\begin_layout Lemma
\begin_inset Formula $T\leq T$
\end_inset

 is admissible.
\end_layout

\begin_layout Proof
This is a straightforward proof by induction.
 
\end_layout

\begin_layout Lemma
\begin_inset Formula $\frac{A\leq B\;\;\; B\leq C}{A\leq C}$
\end_inset

 is admissible.
\end_layout

\begin_layout Proof
By lexicographic induction on the structure of the first and second subtyping
 relations.
\end_layout

\begin_layout Lemma
\begin_inset Formula $T\leq T'$
\end_inset

 and 
\begin_inset Formula $T\sim m$
\end_inset

 and 
\begin_inset Formula $T'\sim m'$
\end_inset

 implies 
\begin_inset Formula $m\leq m'$
\end_inset

.
\end_layout

\begin_layout Proof
By lexicographic induction on the structure of the subtyping relation and
 mode derivations.
 
\end_layout

\begin_layout Subsection
First Pass
\end_layout

\begin_layout Standard
Given that modes are an annotation on the type system, mode checking and
 type checking are done in two passes.
 The first pass ensures that the types with mode annotations are used reasonably
, while the second pass ensures that functions marked as resolving use their
 arguments at least once somewhere that resolves inputs, and will be subsequentl
y called.
 In order to keep type checking simple, we provide it as a lemma that the
 types produced from type checking are mode safe.
 
\end_layout

\begin_layout Definition
\begin_inset Formula $E:T$
\end_inset

 means that expression 
\begin_inset Formula $E$
\end_inset

 has type 
\begin_inset Formula $T$
\end_inset

 and is defined as follows.
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-ASSUM)}\frac{}{\Gamma,x:T\vdash x:T}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-SUBSUMP)}\frac{\Gamma\vdash e:T\;\; T\leq T'\;\; T'\approx m}{\Gamma\vdash e:T'}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-LAM)}\frac{\Gamma,x:T_{1}\vdash e:T_{2}\;\; T_{1}\approx m_{1}\;\;\; T_{2}\approx m_{2}\;\; x\notin V[\Gamma]}{\Gamma\vdash(\lambda x:T_{1}.e):T_{1}\rightarrow T_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-APP)}\frac{\Gamma\vdash e_{1}:T_{1}\rightarrow T_{2}\;\Gamma\vdash e_{2}:T_{1}}{\Gamma\vdash e_{1}e_{2}:T_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-LOGIC-VAR)}\frac{T\approx\ominus}{\Gamma\vdash\mbox{unresolved}:T}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-PROJ)}\frac{\Gamma\vdash a:v_{1}\times v_{2}\;\;\; v_{1}\times v_{2}\approx m}{\Gamma\vdash\pi_{i}a:v_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-Left)}\frac{\Gamma\vdash a:v_{1}\;\;\; v_{1}+_{m}v_{2}\approx m}{\Gamma\vdash\mbox{inl}\; a\;:v_{1}+_{m}v_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-RIGHT)}\frac{\Gamma\vdash a:v_{2}\;\;\; v_{1}+_{m}v_{2}\approx m}{\Gamma\vdash\mbox{inr}\; a\;:v_{1}+_{m}v_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-OBJ)}\frac{\Gamma\vdash e_{1}:v_{1}\;\; v_{1}\sim m\;\;\;\Gamma\vdash e_{2}:v_{2}\;\; v_{2}\sim m}{\Gamma\vdash(e_{1},e_{2}):\; v_{1}\times v_{2}}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-UNIT)}\frac{}{\Gamma\vdash\mbox{unit}:1}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{(OF-CASE-OF)}\frac{\Gamma\vdash l:v_{1}\rightarrow v_{3}\;\;\;\Gamma\vdash r:v_{2}\rightarrow v_{3}\;\;\Gamma\vdash e:v_{1}+_{m}v_{2}\;\; v_{1}\approx m\;\;\; v_{2}\approx m}{\Gamma\vdash\mbox{case}\; e\;\mbox{of}\; l\; r:\; v_{3}}\]

\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Formula $\Gamma\vdash E:T$
\end_inset

 implies that there is a unique 
\begin_inset Formula $m$
\end_inset

 such that 
\begin_inset Formula $T\approx m$
\end_inset

.
\end_layout

\begin_layout Proof
The proof is by induction on the structure of a proof of type.
 There are only three interesting cases however.
 In the case of subsumption, we already ensure the type is well moded.
 In the case of application, the resulting safe mode proof for the left
 hand side after an application of induction must end in 
\begin_inset Formula \[
\mbox{(TP-MODE-SAFE/ARROW)\;}\frac{t_{1}\approx m_{1}\;\; t_{2}\approx m_{2}}{t_{1}\rightarrow t_{2}\approx\oplus}\]

\end_inset

 since it is the only case for an arrow type.
 Since the type of 
\begin_inset Formula $E_{1}\; E_{2}$
\end_inset

 is 
\begin_inset Formula $t_{2}$
\end_inset

 we have a proof of 
\begin_inset Formula $t_{2}\approx m_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
The rest of the proof is formalized in the associated Twelf file, TypeCheckingTh
eorems.elf.
\end_layout

\begin_layout Standard
As our analysis does does not involve 
\series bold
free,
\series default
 
\series bold
findAll
\series default
, 
\series bold
success 
\series default
or
\series bold
 fail
\series default
, we will give their types in polymorphic terms for ease of understanding
 their actions.
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{free}:\forall v_{1}\; v_{2}.(v_{1}\rightarrow\mbox{answer})\rightarrow\mbox{answer}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{findAll}:\forall v.(v\rightarrow\mbox{answer})\rightarrow v+\emptyset\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{success}:answer\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mbox{fail}:answer\]

\end_inset


\end_layout

\begin_layout Standard
We can now introduce some short hand for the remainder of the paper.
 Given that 
\begin_inset Formula $E$
\end_inset

 has already been type checked, we can write that it has a unique type 
\begin_inset Formula $T$
\end_inset

 as 
\begin_inset Formula $E::T$
\end_inset

.
 This can be ensured in an implementation by annotating each term in the
 abstract syntax tree with its associated type during type checking.
 Also, the shorthand 
\begin_inset Formula $E/m$
\end_inset

 is used for 
\begin_inset Formula $E::T$
\end_inset

 and 
\begin_inset Formula $T\sim m$
\end_inset

.
\end_layout

\begin_layout Subsection
Second Pass
\end_layout

\begin_layout Standard
In the second pass, we ensure that functions annotated as resolving use
 their arguments as input to another resolving function in a place that
 will get used.
 The predicate 
\begin_inset Formula $usedCorrectly_{m}(x,E)$
\end_inset

 ensures that 
\begin_inset Formula $x$
\end_inset

 is used as a negative argument to some function in 
\begin_inset Formula $E$
\end_inset

.
 We can generalize even further to allow object arguments by creating another
 predicate 
\begin_inset Formula $objectUsedCorrectly(x,E)$
\end_inset

.
 That argument would have to be used in either both sided of a switch statement,
 have both it's left and right constituents used negatively if it is an
 object, or if we are checking if it is used inside of an application, that
 it is either used on the left hand side, or it is used negatively on the
 right hand side, and the left hand side is strict.
\end_layout

\begin_layout Definition
\begin_inset Formula $usedCorrectly_{m}(X,E)$
\end_inset

 is defined according to the following rules, on type annotated terms 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 and mode 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/VAR)}\frac{}{usedCorrectly_{\ominus}(X,X)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/LAM)}\frac{usedCorrectly_{m}(X,[y/x]E)\;\;\;\;\mbox{x is new}}{usedCorrect_{m}(X,\lambda y:t.E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/APP-L)}\frac{usedCorrectly_{m}(X,E_{1})}{usedCorrectly_{m}(X,E_{1}E_{2})}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/APP-R)}\frac{usedCorrectly_{\ominus}(X,E_{2})\;\; E_{1}::\; t_{1}\rightarrow t_{2}\;\; t_{1}\sim\ominus}{usedCorrect_{m}(X,E_{1}E_{2})}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/OBJ)}\frac{usedCorrectly_{m}(X,E_{1})\;\; usedCorrectly_{m}(X,E_{2})}{usedCorrect_{m}(X,(E_{1},E_{2}))}\]

\end_inset


\begin_inset Formula \[
\mbox{(USED-CORRECTLY/OBJ-L)}\frac{usedCorrectly_{m}(X,E_{1})\;\;(E_{1},E_{2})/\ominus}{usedCorrect_{m}(X,(E_{1},E_{2}))}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/SUM-ARG)}\frac{usedCorrectly_{m}(X,E)}{usedCorrect_{m}(X,\mbox{case}\; E\;\mbox{of}\; E_{1}\; E_{2})}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(USED-CORRECTLY/SUM-C)}\frac{usedCorrectly_{m}(X,E_{1})\;\; usedCorrectly_{m}(X,E_{2})}{usedCorrect_{m}(X,\mbox{case}\; E\;\mbox{of}\; E_{1}\; E_{2})}\]

\end_inset


\end_layout

\begin_layout Standard
We also can show the expansion of an object.
\end_layout

\begin_layout Definition
\begin_inset Formula $objUsedCorrectly_{m}(X,E)$
\end_inset

 is defined according to the following rules.
\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(OBJ-USED/EXP)}\frac{usedCorrectly_{m}(X,E)}{objUsedCorrect_{m}(X,E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(OBJ-USED/PROD)}\frac{objUsedCorrectly_{m}(getLeft\; X,E)\;\; objUsedCorrectly_{m}(getRight\; X,E)}{objUsedCorrect_{m}(X,E)}\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
The predicate 
\begin_inset Formula $wellModed(E)$
\end_inset

 traverses the syntax of a term and only has two rules that are of interest:
\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WM-LAM/POS)}\frac{t\sim\oplus\;\;\;\Gamma,wellModed(x)\vdash wellModed(E)}{\Gamma\vdash wellModed(\lambda x:t.E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WM-LAM/NEG)}\frac{t\sim\ominus\;\;\;\Gamma,wellModed(x)\vdash wellModed(E)\;\;\; objUsedCorrectly(x,E)}{\Gamma\vdash wellModed(\lambda x:t.E)}\]

\end_inset


\end_layout

\begin_layout Lemma
A decidable algorithm to infer types and check well modedness implies mode
 inference is also decidable.
\end_layout

\begin_layout Proof
For every sum type inferred, annotate it with either a positive or negative
 mode.
 Perform the annotated type checking.
 Because there are finite sum nodes in the inferred types, there are finite
 possible mode assignments.
\end_layout

\begin_layout Subsection
Preservation
\end_layout

\begin_layout Standard
Because of submoding, the proof of preservation is slightly more complex
 than in simply typed lambda calculus.
 
\end_layout

\begin_layout Theorem
Preservation
\end_layout

\begin_layout Theorem
\begin_inset Formula $E\Rightarrow E'$
\end_inset

 and 
\begin_inset Formula $\vdash E:T$
\end_inset

 then 
\begin_inset Formula $\vdash E':T'$
\end_inset

 and 
\begin_inset Formula $T'\leq T$
\end_inset

.
\end_layout

\begin_layout Proof
The proof is by lexicographic induction on the reduction and proof of type,
 and it has been formalized in Twelf.
 The intuition behind the subsumption is that as reductions occur, we might
 find out more about the resulting value, but nothing we already know about
 the resulting value will become invalidated.
 In the case of subsumption of a right hand side, the argument for termination
 is more subtle.
 The invariant is made that in an inductive step, no new the size of the
 proof of 
\begin_inset Formula $of$
\end_inset

 never increases, and 
\begin_inset Formula $of/subsump$
\end_inset

 instances always move to the right hand side in the inductive call or disappear
s entirely.
\end_layout

\begin_layout Subsection
Runtime Properties
\end_layout

\begin_layout Standard
The first important theorem about these semantics is that they always result
 in precisely weak head normal form of a value, and thus capture an entire
 computation and not just a computational step.
\end_layout

\begin_layout Definition
\begin_inset Formula $whnf(E)$
\end_inset

 is defined as follows:
\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-OBJ)}whnf((A,B))\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-UNIT)}whnf(\mbox{unit}\mathbf{)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-INL)}whnf(\mbox{inl}\; A\mathbf{)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-INR)}whnf(\mbox{inr}\; A\mathbf{)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-SUCC)}whnf(\mbox{success}\mathbf{)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(WHNF-FAIL)}whnf(\mbox{fail}\mathbf{)}\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $E\Rightarrow V$
\end_inset

 then 
\begin_inset Formula $whnf(V)$
\end_inset


\end_layout

\begin_layout Proof
Simply by lexicographic induction on the structure of a reduction.
 In cases where we reduce twice, the induction argument is invoked on the
 second, output term.
 The E-ID-
\emph on
VTP
\emph default
 cases form the base cases of the proof, where the output proof of 
\begin_inset Formula $whnf$
\end_inset

 is WHNF-
\emph on
VTP
\emph default
.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Note, for sake of brevity, the full small step reduction shall not be defined
 here.
 Instead it will be assumed that it is defined as it usually is and has
 the following operational properties.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $E\Rightarrow_{S}R$
\end_inset


\begin_inset Formula $ $
\end_inset

be the small step reduction such that 
\begin_inset Formula $ $
\end_inset

if 
\begin_inset Formula $E\Rightarrow R$
\end_inset

 then 
\begin_inset Formula $E\Rightarrow_{S}*R$
\end_inset

, and if 
\begin_inset Formula $E\Rightarrow_{S}*R$
\end_inset

and 
\begin_inset Formula $whnf(R)$
\end_inset

 then 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $E\Rightarrow R$
\end_inset


\end_layout

\begin_layout Subsection
Progress
\end_layout

\begin_layout Standard
Before we can prove progress for the full language, we need to prove that
 the sublanguage not considering findAll has the property that it can not
 reduce away logic variables.
\end_layout

\begin_layout Definition
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\mbox{logicFree}(E)$
\end_inset

 shall mean that the term 
\begin_inset Formula $E$
\end_inset

 contains no logic variables in cases where it matters, for example when
 
\begin_inset Formula $E$
\end_inset

 is a value, or when 
\begin_inset Formula $E$
\end_inset

 is not an application of a not necessarily grounding function to any argument.
 
\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/APP})\frac{logicFree(V)\;\; logicFree(F)}{logicFree(F\;\; V)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/LAM})\frac{logicFree(E)}{logicFree(\lambda x.E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/VAR})\frac{}{logicFree(x)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/UNIT})\frac{}{logicFree(unit)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/OBJ-L})\frac{logicFree(E_{1})\;\; E_{2}/\oplus}{logicFree((E_{1},E_{2}))}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/OBJ-R})\frac{logicFree(E_{2})\;\; E_{1}/\oplus}{logicFree((E_{1},E_{2}))}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/OBJ})\frac{logicFree(E_{1})\;\; logicFree(E_{2})}{logicFree((E_{1},E_{2}))}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/INL})\frac{logicFree(E)}{logicFree(\mbox{inl}\; E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/INR})\frac{logicFree(E)}{logicFree(\mbox{inr}\; E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/PROJ})\frac{logicFree(E)}{logicFree(\pi_{i}\; E)}\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mbox{(LFREE/SWITCH})\frac{logicFree(E)\;\; logicFree(L)\;\; logicFree(R)}{logicFree(\mbox{case}\; E\;\mbox{of}\; L\; R)}\]

\end_inset


\end_layout

\begin_layout Lemma
If 
\begin_inset Formula $E\implies_{\alpha}E'$
\end_inset

 and 
\begin_inset Formula $logicFree(E)$
\end_inset

 then 
\begin_inset Formula $logicFree(E')$
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula $\mbox{usedCorrectly}_{m}(X,E)$
\end_inset

 and 
\begin_inset Formula $logicFree(E)$
\end_inset

 implies 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(X)$
\end_inset

.
\end_layout

\begin_layout Proof
By induction on the structure of 
\begin_inset Formula $E$
\end_inset

.
 
\end_layout

\begin_layout Proof
The only case of interest here is 
\begin_inset Formula $\mbox{USED-CORRECTLY/LAM}$
\end_inset

 along with 
\begin_inset Formula $\mbox{LFREE/LAM}$
\end_inset

.
 In this case, where we receive 
\begin_inset Formula $usedCorrectly_{m}(X,\lambda x.E)$
\end_inset

 and 
\begin_inset Formula $logicLess(\lambda x.E)$
\end_inset

.
 We then know 
\begin_inset Formula $usedCorrectly(X,[x/y]E)$
\end_inset

 for some new 
\begin_inset Formula $y$
\end_inset

.
 Thus, 
\begin_inset Formula $E\implies_{\alpha}[x/y]E$
\end_inset

 and 
\begin_inset Formula $logicLess(E)$
\end_inset

 so 
\begin_inset Formula $logicLess([x/y]E)$
\end_inset

 by the above lemma.
 By the induction hypothesis, we know 
\begin_inset Formula $logicLess(X)$
\end_inset

.
 
\end_layout

\begin_layout Corollary
\begin_inset Formula $objUsedCorrectly_{m}(X,E)$
\end_inset

 and 
\begin_inset Formula $logicFree(E)$
\end_inset

 implies 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(X)$
\end_inset

.
\end_layout

\begin_layout Standard
The following theorem is vital to progress, as it ensures that when we search
 by applying values with logical variables in them to the search predicate,
 a successful result can only occur when the argument in fact has no logic
 variables.
 
\end_layout

\begin_layout Theorem
Subterm-Resolving
\end_layout

\begin_layout Theorem
\begin_inset Formula $\Gamma\vdash X:T_{x}$
\end_inset

 and 
\begin_inset Formula $\mbox{usedCorrectly}_{\oplus}(X,E)$
\end_inset

 and 
\begin_inset Formula $\Gamma\vdash E:T_{E}$
\end_inset

 and 
\begin_inset Formula $T_{E}\approx\oplus$
\end_inset

 and 
\begin_inset Formula $E\Rightarrow_{*}V$
\end_inset

 where 
\begin_inset Formula $\Gamma\vdash V:T_{V}$
\end_inset

,  and 
\begin_inset Formula $\mbox{logicFree(V)}$
\end_inset

 then 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(X)$
\end_inset


\end_layout

\begin_layout Proof
This has been mostly proved in Twelf without subtyping for all but a few
 cases.
 The intuition behind this theorem is that 
\begin_inset Formula $usedCorrectly$
\end_inset

 accounts for strict occurrences of 
\begin_inset Formula $X$
\end_inset

 in E, and by definition, an occurrence can only be strict if it will be
 used at least once in the computation required to reduce 
\begin_inset Formula $E$
\end_inset

 completely.
 The remaining cases not currently handled in the Twelf proof are those
 involving expressions used negatively on the left hand side.
 In these cases, subterm resolving follows from preservation of 
\begin_inset Formula $usedCorrectly$
\end_inset

 under substitution.
\end_layout

\begin_layout Corollary
\begin_inset Formula $\Gamma\vdash X:T_{x}$
\end_inset

 and 
\begin_inset Formula $\mbox{objUsedCorrectly}_{\oplus}(X,E)$
\end_inset

 and 
\begin_inset Formula $\Gamma\vdash E:T_{E}$
\end_inset

 and 
\begin_inset Formula $T_{E}\approx\oplus$
\end_inset

 and 
\begin_inset Formula $E\Rightarrow_{k}V$
\end_inset

 with 
\begin_inset Formula $\Gamma\vdash V:T_{V}$
\end_inset

 and 
\begin_inset Formula $T_{V}\leq T_{E}$
\end_inset

 by preservation and 
\begin_inset Formula $\mbox{logicFree(V)}$
\end_inset

 then 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(X)$
\end_inset

and 
\begin_inset Formula $logicFree(E)$
\end_inset

 implies 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(X)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Corollary
Term-Resolving
\end_layout

\begin_layout Corollary
Provided Subterm-Resolving holds in general, 
\begin_inset Formula $\Gamma\vdash X:T_{X}$
\end_inset

 and 
\begin_inset Formula $T_{X}\approx\oplus$
\end_inset

 and 
\begin_inset Formula $X\Rightarrow_{k}V$
\end_inset

 with 
\begin_inset Formula $\Gamma\vdash V:T_{V}$
\end_inset

 and 
\begin_inset Formula $T_{V}\leq T_{X}$
\end_inset

 by preservation and 
\begin_inset Formula $\mbox{logicFree(V)}$
\end_inset

 then 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\mbox{l}\mbox{ogicFree}(X)$
\end_inset


\end_layout

\begin_layout Proof
Given that subterm resolving holds, we can simply apply subterm resolving
 with 
\begin_inset Formula $X$
\end_inset

 for 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $\mbox{usedAsNeg/e}$
\end_inset

 for 
\begin_inset Formula $\mbox{usedAsNeg}(X,X)$
\end_inset

.
\end_layout

\begin_layout Corollary
WellModed-Resolving
\end_layout

\begin_layout Corollary
\begin_inset Formula $\mbox{wellModed}(E)$
\end_inset

 and 
\begin_inset Formula $\Gamma\vdash E:T_{E}$
\end_inset

 and 
\begin_inset Formula $T_{E}\approx\oplus$
\end_inset

 and 
\begin_inset Formula $E\Rightarrow_{*}V$
\end_inset

 with 
\begin_inset Formula $\Gamma\vdash V:T_{V}$
\end_inset

 and 
\begin_inset Formula $T_{V}\leq T_{E}$
\end_inset

 by preservation and 
\begin_inset Formula $\mbox{logicFree(V)}$
\end_inset

 then 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $logicFree(E)$
\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $wellModed(E)$
\end_inset

 , 
\begin_inset Formula $logicFree(E)$
\end_inset

 and 
\begin_inset Formula $E\implies E'$
\end_inset

 then 
\begin_inset Formula $logicFree(E')$
\end_inset

.
\end_layout

\begin_layout Proof
This theorem is by lexicographic induction.
 The only non-trivial cases are those where a logical variable could potentially
 be introduced.
 This restricts us to the cases of 
\begin_inset Formula $findAll$
\end_inset

 and 
\begin_inset Formula $free$
\end_inset

.
\end_layout

\begin_layout Proof
In the case of 
\begin_inset Formula $findAll$
\end_inset

, there are two applicable reductions.
 In the case of 
\begin_inset Formula $\mbox{E-FINDALL-SUCC}$
\end_inset

, corollary 27 can be applied to the reduction 
\begin_inset Formula $E\; V\Rightarrow\mbox{success}$
\end_inset

 to show 
\begin_inset Formula $logicFree(V)$
\end_inset

.
 The output 
\begin_inset Formula $logicFree(left\; V)$
\end_inset

 is an application of 
\begin_inset Formula $\mbox{LFREE-INL}$
\end_inset

.
 The case of 
\begin_inset Formula $\mbox{E-FINDALL-FAIL}$
\end_inset

 is trivial.
 
\end_layout

\begin_layout Proof
In the case of 
\begin_inset Formula $free$
\end_inset

 , both reductions involving it must return values which are certainly resolved.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Theorem
Progress Holds
\end_layout

\begin_layout Theorem
Provided Term-Resolving holds in general, 
\begin_inset Formula $E:T$
\end_inset

 and 
\begin_inset Formula $T\approx\oplus$
\end_inset

 implies either 
\begin_inset Formula $E$
\end_inset

 is a value or 
\begin_inset Formula $E\Rightarrow_{S}E'$
\end_inset

 for some 
\begin_inset Formula $E'$
\end_inset

.
 Furthermore, if 
\begin_inset Formula $E$
\end_inset

 does not contain logic variables, then 
\begin_inset Formula $E'$
\end_inset

 will also contain no logic variables.
\end_layout

\begin_layout Proof
This proof is by lexicographic induction, application of theorem 28, the
 relationship between the small step and big step semantics, and theorem
 18.
 Appart from the cases of 
\begin_inset Formula $findAll$
\end_inset

 and 
\begin_inset Formula $free$
\end_inset

, the proof is similar to traditional proofs of progress.
 We proceed as normal, until the cases of 
\begin_inset Formula $findAll$
\end_inset

 and 
\begin_inset Formula $free$
\end_inset

.
 It makes more sense to say here that 
\begin_inset Formula $findAll$
\end_inset

 of any expression is a value.
 A more meaningful proof of progress can be given if a queue of attempting
 expressions and a set of unattempted expressions is included in the semantics
 for 
\begin_inset Formula $findAll$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Strictness Analysis
\end_layout

\begin_layout Definition
A function E is grounding if when 
\begin_inset Formula $E\; V\implies C$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 has no logic variables, and both 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 are values, then 
\begin_inset Formula $V$
\end_inset

 has no logic variables.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
A function 
\begin_inset Formula $E$
\end_inset

 is strict if 
\begin_inset Formula $E\circ hnf\equiv E$
\end_inset

, where 
\begin_inset Formula $hnf$
\end_inset

 is the function that evaluates it's arguments to head normal form.
 
\end_layout

\begin_layout Proposition
\begin_inset Formula $E$
\end_inset

 is strict iff E is grounding.
\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $E$
\end_inset

 is grounding, then upon completion of 
\begin_inset Formula $E$
\end_inset

, every aspect of its argument must be used, thus evaluating that argument
 to head normal form will not expose any divergent computations not already
 exposed.
 
\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $E$
\end_inset

 is strict.
 then suppose we were to pass an argument to 
\begin_inset Formula $E$
\end_inset

 with logic variables.
 Substitute every logic variable for a divergent computation.
 Then because 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $E$
\end_inset

 is strict, evaluating this argument to head normal form first will not
 change the result of 
\begin_inset Formula $E$
\end_inset

 when passed this argument.
 However, evaluating the argument to head normal form first causes the computati
on to diverge.
 Thus, passing the argument to 
\begin_inset Formula $E$
\end_inset

 will cause the computation to diverge.
 Thus the original argument with logic variables passed to 
\begin_inset Formula $E$
\end_inset

 will either diverge converge to a value with logic variables.
 Thus 
\begin_inset Formula $E$
\end_inset

 is grounding.
 
\end_layout

\begin_layout Corollary
A combinator
\begin_inset Formula $E$
\end_inset

 is strict if 
\begin_inset Formula $\vdash E:I\rightarrow O$
\end_inset

 and 
\begin_inset Formula $I\sim\ominus$
\end_inset

 and 
\begin_inset Formula $O\sim\oplus$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Ramifications
\end_layout

\begin_layout Standard
Because mode checking and strictness checking are equivalent, mode checking
 algorithms can be used for strictness analysis.
 Natural deduction formulations of strictness and relevance logic have been
 given relevant proof terms and could very well be used as an alternate
 type system, with the addition of new syntax.
 In particular, our use of the predicate 
\begin_inset Formula $usedCorrectly$
\end_inset

 coresponds the notion of a strict use of it's argument.
 In this formulation product types can be treated a bit more flexibly.
\end_layout

\begin_layout Standard
The polymorphic linear lambda calculus Lily has been shown to have equivalent
 termination properties under call-by-value and call-by-need semantics.
\begin_inset CommandInset citation
LatexCommand citep
key "lazy-lily"

\end_inset

 In principle, terms like 
\begin_inset Formula $\mathbf{findAll}$
\end_inset

 might be added to Lily and be have groundedness properties ensured.
 
\end_layout

\begin_layout Section
Conclusions & Future Work
\end_layout

\begin_layout Standard
In this thesis, we discussed a lazy functional logic language similar to
 Curry and proved its runtime safety.
 We supplied a mode system and a way to separate nondeterminism from input
 and output.
 However, the mode system is not always entirely expressive enough.
 It is also still necessary to show the safety of extensions of polymorphism
 and recursion to the current mode algorithm.
 Finally, a full implementation of the language has yet to be completed.
 
\end_layout

\begin_layout Standard
Strictness type systems based on natural deduction formulations of resource
 logic have been defined, but type systems based on them including fixed
 points and polymorphism do not yet seem to have been examined.
 It would also be interesting to explore the sorts of safe concurrency primitive
s that could be created using the same principles as 
\series bold
findAll
\series default
.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "/Users/matt/Documents/MyBib"
options "bibtotoc,amsplain"

\end_inset


\end_layout

\begin_layout Remark*
The Twelf proofs will be available at 
\begin_inset CommandInset href
LatexCommand href
name "http://github.com/mmirman/korma"
target "http://github.com/mmirman/korma"

\end_inset

 in the branches simple and explicit.
 
\end_layout

\end_body
\end_document
